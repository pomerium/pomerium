#!/bin/bash
# Git merge driver for internal/version/components.json
# Resolves conflicts by picking the highest semver for each component
#
# Usage: merge-components-json %O %A %B
#   %O = ancestor (base)
#   %A = current (ours) - result is written here
#   %B = other (theirs)

set -euo pipefail

ANCESTOR="$1"
CURRENT="$2"
OTHER="$3"

# Compare two semver strings, return 0 if $1 >= $2
semver_gte() {
    local v1="${1#v}"
    local v2="${2#v}"

    local IFS='.'
    read -ra parts1 <<< "$v1"
    read -ra parts2 <<< "$v2"

    for i in 0 1 2; do
        local p1="${parts1[$i]:-0}"
        local p2="${parts2[$i]:-0}"
        if (( p1 > p2 )); then
            return 0
        elif (( p1 < p2 )); then
            return 1
        fi
    done
    return 0
}

# Get the higher of two semver versions
max_semver() {
    if semver_gte "$1" "$2"; then
        echo "$1"
    else
        echo "$2"
    fi
}

# Merge the JSON files, picking highest semver for each key
merge_json() {
    local ancestor="$1"
    local current="$2"
    local other="$3"

    # Get all keys from all three files
    local all_keys
    all_keys=$(jq -r 'keys[]' "$ancestor" "$current" "$other" 2>/dev/null | sort -u)

    echo "{"
    local first=true
    for key in $all_keys; do
        local v_ancestor v_current v_other result

        v_ancestor=$(jq -r --arg k "$key" '.[$k] // ""' "$ancestor" 2>/dev/null || echo "")
        v_current=$(jq -r --arg k "$key" '.[$k] // ""' "$current" 2>/dev/null || echo "")
        v_other=$(jq -r --arg k "$key" '.[$k] // ""' "$other" 2>/dev/null || echo "")

        # Start with current version (or empty)
        result="$v_current"

        # Compare with ancestor - if empty, use ancestor
        if [[ -z "$result" && -n "$v_ancestor" ]]; then
            result="$v_ancestor"
        elif [[ -n "$result" && -n "$v_ancestor" ]]; then
            result=$(max_semver "$result" "$v_ancestor")
        fi

        # Compare with other - if empty, use other
        if [[ -z "$result" && -n "$v_other" ]]; then
            result="$v_other"
        elif [[ -n "$result" && -n "$v_other" ]]; then
            result=$(max_semver "$result" "$v_other")
        fi

        # Skip if no version found
        [[ -z "$result" ]] && continue

        if $first; then
            first=false
        else
            echo ","
        fi
        printf '  "%s": "%s"' "$key" "$result"
    done
    echo ""
    echo "}"
}

# Perform the merge and write to CURRENT (git expects result in %A)
merge_json "$ANCESTOR" "$CURRENT" "$OTHER" > "$CURRENT.merged"
mv "$CURRENT.merged" "$CURRENT"

exit 0
