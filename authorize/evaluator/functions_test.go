package evaluator

import (
	"encoding/asn1"
	"regexp"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/pomerium/pomerium/config"
)

// These certificates can be regenerated by running:
//
//	go run ./gen-test-certs.go
//
// (Copy and paste the output here.)
const (
	testCA = `
-----BEGIN CERTIFICATE-----
MIIBZzCCAQ6gAwIBAgICEAAwCgYIKoZIzj0EAwIwGjEYMBYGA1UEAxMPVHJ1c3Rl
ZCBSb290IENBMCAYDzAwMDEwMTAxMDAwMDAwWhcNMzQwNzIxMjEwOTAxWjAaMRgw
FgYDVQQDEw9UcnVzdGVkIFJvb3QgQ0EwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNC
AATMLdnk1HSlNQCNimWztrBbBU0xghli5LWSk7P1/1CW3JPvujT0xC2tEpooAxWi
XECL22GH9E2pH/dQoDj2FP41o0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/
BAUwAwEB/zAdBgNVHQ4EFgQUoLhiwb9DEY80NUm/XfiLszTnetcwCgYIKoZIzj0E
AwIDRwAwRAIgWWAReqEjmvzpUKupOlcmEA4WBoPpsWWTDzFFApWE/+0CIG6FEkwQ
rJ4htyRqNMapRJmIHqgVxhyV/Pb7t4tsp6d7
-----END CERTIFICATE-----
`
	testValidCert = `
-----BEGIN CERTIFICATE-----
MIIBYjCCAQigAwIBAgICEAEwCgYIKoZIzj0EAwIwGjEYMBYGA1UEAxMPVHJ1c3Rl
ZCBSb290IENBMCAYDzAwMDEwMTAxMDAwMDAwWhcNMzQwNzIxMjEwOTAxWjAeMRww
GgYDVQQDExN0cnVzdGVkIGNsaWVudCBjZXJ0MFkwEwYHKoZIzj0CAQYIKoZIzj0D
AQcDQgAEUk42ibrv64GOkeoZdw+AUiohrtmg2g89jq60E7+HPBrDHWI+jZ22EtBe
N9pphc6hktrlGM3oHn95NOemJ/mlAaM4MDYwEwYDVR0lBAwwCgYIKwYBBQUHAwIw
HwYDVR0jBBgwFoAUoLhiwb9DEY80NUm/XfiLszTnetcwCgYIKoZIzj0EAwIDSAAw
RQIgGVB3Q4gFtZNgzjUUe1TuhJLy4NY1vRMrtVk1ywEC4hoCIQCg7XSIirpS4Mxc
kB9Ugn4FUX8SDD5+md2IReM27uKBjw==
-----END CERTIFICATE-----
`
	testUntrustedCert = `
-----BEGIN CERTIFICATE-----
MIIBZTCCAQygAwIBAgICEAEwCgYIKoZIzj0EAwIwHDEaMBgGA1UEAxMRVW50cnVz
dGVkIFJvb3QgQ0EwIBgPMDAwMTAxMDEwMDAwMDBaFw0zNDA3MjEyMTA5MDFaMCAx
HjAcBgNVBAMTFXVudHJ1c3RlZCBjbGllbnQgY2VydDBZMBMGByqGSM49AgEGCCqG
SM49AwEHA0IABMD1+g0Dx5xcezQWJsWJX9AoNlPLsaqspsVS/rJoMoa01gE3fh8y
KaVH3N/SQH4E54TUywJA06wSIGN3SsNgpnajODA2MBMGA1UdJQQMMAoGCCsGAQUF
BwMCMB8GA1UdIwQYMBaAFHqcIcMoPGoBDLYSIol5EqKgXAA+MAoGCCqGSM49BAMC
A0cAMEQCIDCSM5mZkwApd+Ne0fYK3o0dP9CKeEd31lzF9PlMAzU2AiBL8EBVN5T6
M74llANbsQV6/9O3WSDYsvxvAGK/aN2pBg==
-----END CERTIFICATE-----
`
	testRevokedCert = `
-----BEGIN CERTIFICATE-----
MIIBYjCCAQigAwIBAgICEAIwCgYIKoZIzj0EAwIwGjEYMBYGA1UEAxMPVHJ1c3Rl
ZCBSb290IENBMCAYDzAwMDEwMTAxMDAwMDAwWhcNMzQwNzIxMjEwOTAxWjAeMRww
GgYDVQQDExNyZXZva2VkIGNsaWVudCBjZXJ0MFkwEwYHKoZIzj0CAQYIKoZIzj0D
AQcDQgAEfOs33d2sg3TQg19dh1bA5gv+wUljqfkykl/rj5vh3PwMoNgf38M09Lbs
fT6kz7wpKEA0G9/h/f2c4y59/d34ZqM4MDYwEwYDVR0lBAwwCgYIKwYBBQUHAwIw
HwYDVR0jBBgwFoAUoLhiwb9DEY80NUm/XfiLszTnetcwCgYIKoZIzj0EAwIDSAAw
RQIhAKNJwVxMvKIjkMfk9JhePG24CGawlIzCMJLRExQnIxzoAiAbMOnxje3tr/Mg
kl9linML1Km4f5aqOp2+TF9O/EHhKg==
-----END CERTIFICATE-----
`
	testCRL = `
-----BEGIN X509 CRL-----
MIHdMIGFAgEBMAoGCCqGSM49BAMCMBoxGDAWBgNVBAMTD1RydXN0ZWQgUm9vdCBD
QRgPMDAwMTAxMDEwMDAwMDBaMBUwEwICEAIXDTI0MDcyMzIxMDkwMVqgMDAuMB8G
A1UdIwQYMBaAFKC4YsG/QxGPNDVJv134i7M053rXMAsGA1UdFAQEAgIgADAKBggq
hkjOPQQDAgNHADBEAiA6zjKyqK0IE8bO/LtnQT2CSRolOcdwHPMjtTkoO7ht8gIg
Qo8S83mFqwG14NiwaudxpYyYfGcCJZ6aaxqLc03ixiA=
-----END X509 CRL-----
`
	testIntermediateCA = `
-----BEGIN CERTIFICATE-----
MIIBkTCCATegAwIBAgICEAMwCgYIKoZIzj0EAwIwGjEYMBYGA1UEAxMPVHJ1c3Rl
ZCBSb290IENBMCAYDzAwMDEwMTAxMDAwMDAwWhcNMzQwNzIxMjEwOTAxWjAiMSAw
HgYDVQQDExdUcnVzdGVkIEludGVybWVkaWF0ZSBDQTBZMBMGByqGSM49AgEGCCqG
SM49AwEHA0IABNPOBn1f6EJYlOBs9E4ZllV3rVvzGbh7Z3f3klIfKv0nmYZqTYsE
06GbMlc+Rdw//wQ40j9+Gnvk/yTVPUydtSSjYzBhMA4GA1UdDwEB/wQEAwIBBjAP
BgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQtnNz7iWzU1Fp427ksQsEf31WvgTAf
BgNVHSMEGDAWgBSguGLBv0MRjzQ1Sb9d+IuzNOd61zAKBggqhkjOPQQDAgNIADBF
AiEAzOI48p3sxhFnpp2s0LFxjzQXwOUqsKtlkWh16hEzG4MCIGspIDiBlxE594+M
iiciSIzesgppOJb1Hk/JS9r6qYhz
-----END CERTIFICATE-----
`
	testValidIntermediateCert = `
-----BEGIN CERTIFICATE-----
MIIBdTCCARqgAwIBAgICEAAwCgYIKoZIzj0EAwIwIjEgMB4GA1UEAxMXVHJ1c3Rl
ZCBJbnRlcm1lZGlhdGUgQ0EwIBgPMDAwMTAxMDEwMDAwMDBaFw0zNDA3MjEyMTA5
MDFaMCgxJjAkBgNVBAMTHWNsaWVudCBjZXJ0IGZyb20gaW50ZXJtZWRpYXRlMFkw
EwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEi9mkxtKlhiiCHteqDHZP+YH4awImLtEx
i7s/Nt1AWp3VMQ/cxRsZcmRHceGIpPoinYpmGfVppxy9fddZ4IBjw6M4MDYwEwYD
VR0lBAwwCgYIKwYBBQUHAwIwHwYDVR0jBBgwFoAULZzc+4ls1NRaeNu5LELBH99V
r4EwCgYIKoZIzj0EAwIDSQAwRgIhAJGUfGvzsTwMMqLzhSNdmKUWyajbN+wRF2gr
3CzI77OZAiEAh40Bew0mQQUs3WWilY0BauxtDtdcjX/IerxKTzEXKbg=
-----END CERTIFICATE-----
`
	testValidCertWithDNSSANs = `
-----BEGIN CERTIFICATE-----
MIIBlDCCATugAwIBAgICEAQwCgYIKoZIzj0EAwIwGjEYMBYGA1UEAxMPVHJ1c3Rl
ZCBSb290IENBMCAYDzAwMDEwMTAxMDAwMDAwWhcNMzQwNzIxMjEwOTAxWjAYMRYw
FAYDVQQDEw1jbGllbnQgY2VydCAzMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
Dw9uoVvSDyVpqRN79Dtd3pf8pbTTKV8ZFDMa+pft3cWCSbzsxkHjx5yfiYmy94m0
IAUEkpsivA7w5zqhqZfONaNxMG8wEwYDVR0lBAwwCgYIKwYBBQUHAwIwHwYDVR0j
BBgwFoAUoLhiwb9DEY80NUm/XfiLszTnetcwNwYDVR0RBDAwLoIVYS5jbGllbnQz
LmV4YW1wbGUuY29tghViLmNsaWVudDMuZXhhbXBsZS5jb20wCgYIKoZIzj0EAwID
RwAwRAIgTgkgYXb/6sErId2S/1X8TkdQETmMeQ85e0zQLC2WGn0CIAPF5nrlf5EL
VLK0wso+qCFmqrPNnv4X8nYOEc3L7kPA
-----END CERTIFICATE-----
`
	testValidCertWithEmailSAN = `
-----BEGIN CERTIFICATE-----
MIIBfTCCASKgAwIBAgICEAUwCgYIKoZIzj0EAwIwGjEYMBYGA1UEAxMPVHJ1c3Rl
ZCBSb290IENBMCAYDzAwMDEwMTAxMDAwMDAwWhcNMzQwNzIxMjEwOTAxWjAYMRYw
FAYDVQQDEw1jbGllbnQgY2VydCA0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
zMPGmaQ/Hhss/Pil1ku5QgFmVkaZdMHllql508HddNQ96t24vddILPS1YZwRv1SQ
D47sdwRcrgLcYvXAYhnfxKNYMFYwEwYDVR0lBAwwCgYIKwYBBQUHAwIwHwYDVR0j
BBgwFoAUoLhiwb9DEY80NUm/XfiLszTnetcwHgYDVR0RBBcwFYETY2xpZW50NEBl
eGFtcGxlLmNvbTAKBggqhkjOPQQDAgNJADBGAiEAiKp/7Cv8tUJBUr+Z+T6ztghs
hhSH/LZcLzRHJ8jtACoCIQD78Ut4V6/8eSOS3DHIDwqXwOZ/L06DwugzYP5/jlZA
cQ==
-----END CERTIFICATE-----
`
	testValidCertWithIPSAN = `
-----BEGIN CERTIFICATE-----
MIIBbTCCAROgAwIBAgICEAYwCgYIKoZIzj0EAwIwGjEYMBYGA1UEAxMPVHJ1c3Rl
ZCBSb290IENBMCAYDzAwMDEwMTAxMDAwMDAwWhcNMzQwNzIxMjEwOTAxWjAYMRYw
FAYDVQQDEw1jbGllbnQgY2VydCA1MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
cRD582BfNyLzyuvtxR/Z19mwWqRF6Kxx5ZSovtPKIeJ75Okiv1q20TOwGrEYLmHr
YCBrMd3YM56KKcEhSUi/nqNJMEcwEwYDVR0lBAwwCgYIKwYBBQUHAwIwHwYDVR0j
BBgwFoAUoLhiwb9DEY80NUm/XfiLszTnetcwDwYDVR0RBAgwBocEwKgKCjAKBggq
hkjOPQQDAgNIADBFAiAv+MGYGG9SaQFekl1e7zIG0rxMkbS8UPmkklR/RuXQ+gIh
ALvBj9aAXW9wN8nYLH9L2bPbMT//a42VuD6qvi6B0i6P
-----END CERTIFICATE-----
`
	testValidCertWithURISAN = `
-----BEGIN CERTIFICATE-----
MIIBhTCCASugAwIBAgICEAcwCgYIKoZIzj0EAwIwGjEYMBYGA1UEAxMPVHJ1c3Rl
ZCBSb290IENBMCAYDzAwMDEwMTAxMDAwMDAwWhcNMzQwNzIxMjEwOTAxWjAYMRYw
FAYDVQQDEw1jbGllbnQgY2VydCA2MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
B7Znrqifp50mCqJfdoCvEu0UP+W1qUZm1dckfMq02f9kgbn2JGgvb1nGE8gKA0n1
V6/QtuIUBnyosfX3IuF9qqNhMF8wEwYDVR0lBAwwCgYIKwYBBQUHAwIwHwYDVR0j
BBgwFoAUoLhiwb9DEY80NUm/XfiLszTnetcwJwYDVR0RBCAwHoYcc3BpZmZlOi8v
ZXhhbXBsZS5jb20vZm9vL2JhcjAKBggqhkjOPQQDAgNIADBFAiAwp1maaT976oWE
f8RnxAPGX1Ecc77A6uhOM0ZCVrYDCQIhAJf5MW7BddAtbRYHyUEhwaVFA9Ci56m9
TEgriIGNirO9
-----END CERTIFICATE-----
`
	testValidCertWithUPNSAN = `
-----BEGIN CERTIFICATE-----
MIIBhDCCASqgAwIBAgICEAcwCgYIKoZIzj0EAwIwGjEYMBYGA1UEAxMPVHJ1c3Rl
ZCBSb290IENBMCAYDzAwMDEwMTAxMDAwMDAwWhcNMzQwNzIxMjEwOTAxWjAYMRYw
FAYDVQQDEw1jbGllbnQgY2VydCA3MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
Pbsk3ZsS7dPwVh+G+hG/nv9PcHfFpOrCiAP0/orxhTRiYD2QbxCB9KBC2YZKrMGF
pvhqM/fX6r1hB6o1Gz/J3KNgMF4wEwYDVR0lBAwwCgYIKwYBBQUHAwIwHwYDVR0j
BBgwFoAUoLhiwb9DEY80NUm/XfiLszTnetcwJgYDVR0RBB8wHaAbBgorBgEEAYI3
FAIDoA0MC3Rlc3RfZGV2aWNlMAoGCCqGSM49BAMCA0gAMEUCIQDG82BiX0pzkvW+
UgGq54X7ItNLu2uBFBTgR8NCJpBCMAIgaBzSkAyTSbbLU/gRrhD6HiyGoxDn38xh
HcsXWWvNgTQ=
-----END CERTIFICATE-----
`
)

func Test_isValidClientCertificate(t *testing.T) {
	t.Parallel()

	var noConstraints ClientCertConstraints
	t.Run("no ca", func(t *testing.T) {
		valid, err := isValidClientCertificate(
			"", "", ClientCertificateInfo{Leaf: "WHATEVER!"}, noConstraints)
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")
	})
	t.Run("no cert", func(t *testing.T) {
		valid, err := isValidClientCertificate(testCA, "", ClientCertificateInfo{}, noConstraints)
		assert.NoError(t, err, "should not return an error")
		assert.False(t, valid, "should return false")
	})
	t.Run("valid cert", func(t *testing.T) {
		valid, err := isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCert,
		}, noConstraints)
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")
	})
	t.Run("valid cert with intermediate", func(t *testing.T) {
		valid, err := isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented:     true,
			Leaf:          testValidIntermediateCert,
			Intermediates: testIntermediateCA,
		}, noConstraints)
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")
	})
	t.Run("valid cert missing intermediate", func(t *testing.T) {
		valid, err := isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented:     true,
			Leaf:          testValidIntermediateCert,
			Intermediates: "",
		}, noConstraints)
		assert.NoError(t, err, "should not return an error")
		assert.False(t, valid, "should return false")
	})
	t.Run("intermediate CA as root", func(t *testing.T) {
		valid, err := isValidClientCertificate(testIntermediateCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidIntermediateCert,
		}, noConstraints)
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")
	})
	t.Run("unsigned cert", func(t *testing.T) {
		valid, err := isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testUntrustedCert,
		}, noConstraints)
		assert.NoError(t, err, "should not return an error")
		assert.False(t, valid, "should return false")
	})
	t.Run("not a cert", func(t *testing.T) {
		valid, err := isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      "WHATEVER!",
		}, noConstraints)
		assert.Error(t, err, "should return an error")
		assert.False(t, valid, "should return false")
	})
	t.Run("revoked cert", func(t *testing.T) {
		revokedCertInfo := ClientCertificateInfo{
			Presented: true,
			Leaf:      testRevokedCert,
		}

		// The "revoked cert" should otherwise be valid (when no CRL is specified).
		valid, err := isValidClientCertificate(testCA, "", revokedCertInfo, noConstraints)
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")

		valid, err = isValidClientCertificate(testCA, testCRL, revokedCertInfo, noConstraints)
		assert.NoError(t, err, "should not return an error")
		assert.False(t, valid, "should return false")

		// Specifying a CRL containing the revoked cert should not affect other certs.
		valid, err = isValidClientCertificate(testCA, testCRL, ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCert,
		}, noConstraints)
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")
	})
	t.Run("chain too deep", func(t *testing.T) {
		valid, err := isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented:     true,
			Leaf:          testValidIntermediateCert,
			Intermediates: testIntermediateCA,
		}, ClientCertConstraints{MaxVerifyDepth: 1})
		assert.NoError(t, err, "should not return an error")
		assert.False(t, valid, "should return false")
	})
	t.Run("any SAN", func(t *testing.T) {
		matchAnySAN := ClientCertConstraints{SANMatchers: SANMatchers{
			config.SANTypeDNS:       regexp.MustCompile("^.*$"),
			config.SANTypeEmail:     regexp.MustCompile("^.*$"),
			config.SANTypeIPAddress: regexp.MustCompile("^.*$"),
			config.SANTypeURI:       regexp.MustCompile("^.*$"),
		}}

		valid, err := isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCert, // no SANs
		}, matchAnySAN)
		assert.NoError(t, err, "should not return an error")
		assert.False(t, valid, "should return false")

		valid, err = isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithDNSSANs,
		}, matchAnySAN)
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")

		valid, err = isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithEmailSAN,
		}, matchAnySAN)
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")

		valid, err = isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithIPSAN,
		}, matchAnySAN)
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")

		valid, err = isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithURISAN,
		}, matchAnySAN)
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")
	})
	t.Run("DNS SAN", func(t *testing.T) {
		valid, err := isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithDNSSANs,
		}, ClientCertConstraints{SANMatchers: SANMatchers{
			config.SANTypeDNS: regexp.MustCompile(`^a\..*\.example\.com$`),
		}})
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")

		valid, err = isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithDNSSANs,
		}, ClientCertConstraints{SANMatchers: SANMatchers{
			config.SANTypeEmail: regexp.MustCompile(`^a\..*\.example\.com$`), // mismatched type
		}})
		assert.NoError(t, err, "should not return an error")
		assert.False(t, valid, "should return false")
	})
	t.Run("email SAN", func(t *testing.T) {
		valid, err := isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithEmailSAN,
		}, ClientCertConstraints{SANMatchers: SANMatchers{
			config.SANTypeEmail: regexp.MustCompile(`^.*@example\.com$`),
		}})
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")

		valid, err = isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithEmailSAN,
		}, ClientCertConstraints{SANMatchers: SANMatchers{
			config.SANTypeIPAddress: regexp.MustCompile(`^.*@example\.com$`), // mismatched type
		}})
		assert.NoError(t, err, "should not return an error")
		assert.False(t, valid, "should return false")
	})
	t.Run("IP address SAN", func(t *testing.T) {
		valid, err := isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithIPSAN,
		}, ClientCertConstraints{SANMatchers: SANMatchers{
			config.SANTypeIPAddress: regexp.MustCompile(`^192\.168\.10\..*$`),
		}})
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")

		valid, err = isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithIPSAN,
		}, ClientCertConstraints{SANMatchers: SANMatchers{
			config.SANTypeURI: regexp.MustCompile(`^192\.168\.10\..*$`), // mismatched type
		}})
		assert.NoError(t, err, "should not return an error")
		assert.False(t, valid, "should return false")
	})
	t.Run("URI SAN", func(t *testing.T) {
		valid, err := isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithURISAN,
		}, ClientCertConstraints{SANMatchers: SANMatchers{
			config.SANTypeURI: regexp.MustCompile(`^spiffe://example\.com/.*$`),
		}})
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")

		valid, err = isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithURISAN,
		}, ClientCertConstraints{SANMatchers: SANMatchers{
			config.SANTypeDNS: regexp.MustCompile(`^spiffe://example\.com/.*$`), // mismatched type
		}})
		assert.NoError(t, err, "should not return an error")
		assert.False(t, valid, "should return false")
	})
	t.Run("UserPrincipalName SAN", func(t *testing.T) {
		valid, err := isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithUPNSAN,
		}, ClientCertConstraints{SANMatchers: SANMatchers{
			config.SANTypeUserPrincipalName: regexp.MustCompile(`^test_device$`),
		}})
		assert.NoError(t, err, "should not return an error")
		assert.True(t, valid, "should return true")

		valid, err = isValidClientCertificate(testCA, "", ClientCertificateInfo{
			Presented: true,
			Leaf:      testValidCertWithURISAN,
		}, ClientCertConstraints{SANMatchers: SANMatchers{
			config.SANTypeDNS: regexp.MustCompile(`^test-device$`), // mismatched type
		}})
		assert.NoError(t, err, "should not return an error")
		assert.False(t, valid, "should return false")
	})
}

func TestClientCertConstraintsFromConfig(t *testing.T) {
	t.Parallel()

	t.Run("default constraints", func(t *testing.T) {
		var s config.DownstreamMTLSSettings
		c, err := ClientCertConstraintsFromConfig(&s)
		assert.NoError(t, err)
		assert.Equal(t, &ClientCertConstraints{MaxVerifyDepth: 1}, c)
	})
	t.Run("no constraints", func(t *testing.T) {
		s := config.DownstreamMTLSSettings{
			MaxVerifyDepth: new(uint32),
		}
		c, err := ClientCertConstraintsFromConfig(&s)
		assert.NoError(t, err)
		assert.Equal(t, &ClientCertConstraints{}, c)
	})
	t.Run("larger max depth", func(t *testing.T) {
		depth := uint32(5)
		s := config.DownstreamMTLSSettings{
			MaxVerifyDepth: &depth,
		}
		c, err := ClientCertConstraintsFromConfig(&s)
		assert.NoError(t, err)
		assert.Equal(t, &ClientCertConstraints{MaxVerifyDepth: 5}, c)
	})
	t.Run("one SAN match", func(t *testing.T) {
		s := config.DownstreamMTLSSettings{
			MatchSubjectAltNames: []config.SANMatcher{
				{Type: config.SANTypeDNS, Pattern: `.*\.corp\.example\.com`},
			},
		}
		c, err := ClientCertConstraintsFromConfig(&s)
		assert.NoError(t, err)
		assert.Equal(t, &ClientCertConstraints{
			MaxVerifyDepth: 1,
			SANMatchers: SANMatchers{
				config.SANTypeDNS: regexp.MustCompile(`^(.*\.corp\.example\.com)$`),
			},
		}, c)
	})
	t.Run("multiple SAN matches", func(t *testing.T) {
		s := config.DownstreamMTLSSettings{
			MatchSubjectAltNames: []config.SANMatcher{
				{Type: config.SANTypeDNS, Pattern: `.*\.foo\.example\.com`},
				{Type: config.SANTypeDNS, Pattern: `.*\.bar\.example\.com`},
			},
		}
		c, err := ClientCertConstraintsFromConfig(&s)
		assert.NoError(t, err)
		assert.Equal(t, &ClientCertConstraints{
			MaxVerifyDepth: 1,
			SANMatchers: SANMatchers{
				config.SANTypeDNS: regexp.MustCompile(`^(.*\.foo\.example\.com)|(.*\.bar\.example\.com)$`),
			},
		}, c)
	})
	t.Run("multiple SAN matches", func(t *testing.T) {
		s := config.DownstreamMTLSSettings{
			MatchSubjectAltNames: []config.SANMatcher{
				{Type: config.SANTypeDNS, Pattern: `.*\.foo\.example\.com`},
				{Type: config.SANTypeEmail, Pattern: `.*@example\.com`},
			},
		}
		c, err := ClientCertConstraintsFromConfig(&s)
		assert.NoError(t, err)
		assert.Equal(t, &ClientCertConstraints{
			MaxVerifyDepth: 1,
			SANMatchers: SANMatchers{
				config.SANTypeDNS:   regexp.MustCompile(`^(.*\.foo\.example\.com)$`),
				config.SANTypeEmail: regexp.MustCompile(`^(.*@example\.com)$`),
			},
		}, c)
	})
	t.Run("bad SAN match expression", func(t *testing.T) {
		s := config.DownstreamMTLSSettings{
			MatchSubjectAltNames: []config.SANMatcher{
				{Type: config.SANTypeDNS, Pattern: "["},
			},
		}
		_, err := ClientCertConstraintsFromConfig(&s)
		require.Error(t, err)
	})
}

func TestGetUserPrincipalNamesFromSAN(t *testing.T) {
	type OtherName[T any] struct {
		TypeID asn1.ObjectIdentifier
		Value  T `asn1:"tag:0"`
	}
	type PrintableString struct {
		Value string
	}
	type IA5String struct {
		Value string `asn1:"ia5"`
	}
	type UTF8String struct {
		Value string `asn1:"utf8"`
	}
	upn := func(name string) OtherName[UTF8String] {
		return OtherName[UTF8String]{
			TypeID: asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 311, 20, 2, 3},
			Value:  UTF8String{name},
		}
	}

	t.Run("OneUserPrincipalName", func(t *testing.T) {
		type SAN struct {
			UPN OtherName[UTF8String] `asn1:"tag:0"`
		}
		san, err := asn1.Marshal(SAN{upn("hello")})
		require.NoError(t, err)

		names, err := getUserPrincipalNamesFromSAN(san)
		assert.NoError(t, err)
		assert.Equal(t, []string{"hello"}, names)
	})
	t.Run("MultipleUserPrincipalNames", func(t *testing.T) {
		type SAN struct {
			UPN1 OtherName[UTF8String] `asn1:"tag:0"`
			UPN2 OtherName[UTF8String] `asn1:"tag:0"`
			UPN3 OtherName[UTF8String] `asn1:"tag:0"`
		}
		san, err := asn1.Marshal(SAN{upn("foo"), upn("bar"), upn("baz")})
		require.NoError(t, err)

		names, err := getUserPrincipalNamesFromSAN(san)
		assert.NoError(t, err)
		assert.Equal(t, []string{"foo", "bar", "baz"}, names)
	})
	t.Run("NoUserPrincipalName", func(t *testing.T) {
		type SAN struct {
			DNS   string `asn1:"tag:2,ia5"`
			IP    []byte `asn1:"tag:7"`
			Email string `asn1:"tag:1,ia5"`
		}
		san, err := asn1.Marshal(SAN{
			"localhost",
			[]byte{127, 0, 0, 1},
			"me@example.com",
		})
		require.NoError(t, err)

		names, err := getUserPrincipalNamesFromSAN(san)
		assert.NoError(t, err)
		assert.Empty(t, names)
	})
	t.Run("MultipleNameTypes", func(t *testing.T) {
		type SAN struct {
			DNS1   string                     `asn1:"tag:2,ia5"`
			DNS2   string                     `asn1:"tag:2,ia5"`
			Other1 OtherName[IA5String]       `asn1:"tag:0"`
			Other2 OtherName[UTF8String]      `asn1:"tag:0"`
			Other3 OtherName[PrintableString] `asn1:"tag:0"`
		}
		san, err := asn1.Marshal(SAN{
			"example.com",
			"example.org",
			OtherName[IA5String]{
				TypeID: asn1.ObjectIdentifier{1, 1, 1, 1},
				Value:  IA5String{"IA5String"},
			},
			upn("UserPrincipalName"),
			OtherName[PrintableString]{
				TypeID: asn1.ObjectIdentifier{1, 1, 1, 2},
				Value:  PrintableString{"PrintableString"},
			},
		})
		require.NoError(t, err)

		names, err := getUserPrincipalNamesFromSAN(san)
		assert.NoError(t, err)
		assert.Equal(t, []string{"UserPrincipalName"}, names)
	})
	t.Run("UserPrincipalNameWrongValueType", func(t *testing.T) {
		type SAN struct {
			UPN OtherName[PrintableString] `asn1:"tag:0"`
		}
		san, err := asn1.Marshal(SAN{
			OtherName[PrintableString]{
				TypeID: asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 311, 20, 2, 3},
				Value:  PrintableString{"PrintableString"},
			},
		})
		require.NoError(t, err)

		names, err := getUserPrincipalNamesFromSAN(san)
		assert.ErrorContains(t, err, "expected UTF8String")
		assert.Empty(t, names)
	})
	t.Run("EmptySAN", func(t *testing.T) {
		names, err := getUserPrincipalNamesFromSAN(nil)
		assert.ErrorContains(t, err, "error reading GeneralNames sequence")
		assert.Empty(t, names)
	})
	t.Run("TruncatedGeneralName", func(t *testing.T) {
		san := []byte{0x30, 0x02, 0x82, 0x05 /* 5 more bytes expected */}
		names, err := getUserPrincipalNamesFromSAN(san)
		assert.ErrorContains(t, err, "error reading GeneralName")
		assert.Empty(t, names)
	})
	t.Run("OtherNameWrongTypeIDType", func(t *testing.T) {
		san := []byte{0x30, 0x06, 0xa0, 0x04, 0x02 /* type Integer, not OID */, 0x02, 0x46, 0x01}
		names, err := getUserPrincipalNamesFromSAN(san)
		assert.ErrorContains(t, err, "error reading OtherName type ID")
		assert.Empty(t, names)
	})
	t.Run("UserPrincipalNameWrongValueTag", func(t *testing.T) {
		type BadOtherName struct {
			TypeID asn1.ObjectIdentifier
			Value  UTF8String `asn1:"tag:1"` // instead of tag 0
		}
		type SAN struct {
			UPN BadOtherName `asn1:"tag:0"`
		}
		san, err := asn1.Marshal(SAN{
			UPN: BadOtherName{
				TypeID: oidUserPrincipalName,
				Value:  UTF8String{"hello"},
			},
		})
		require.NoError(t, err)

		names, err := getUserPrincipalNamesFromSAN(san)
		assert.ErrorContains(t, err, "error reading UserPrincipalName value")
		assert.Empty(t, names)
	})
}
