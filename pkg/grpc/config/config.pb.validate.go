// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: config.proto

package config

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Config with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Config) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Config with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ConfigMultiError, or nil if none found.
func (m *Config) ValidateAll() error {
	return m.validate(true)
}

func (m *Config) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetRoutes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigValidationError{
					field:  fmt.Sprintf("Routes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigValidationError{
				field:  "Settings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConfigMultiError(errors)
	}

	return nil
}

// ConfigMultiError is an error wrapping multiple validation errors returned by
// Config.ValidateAll() if the designated constraints aren't met.
type ConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMultiError) AllErrors() []error { return m }

// ConfigValidationError is the validation error returned by Config.Validate if
// the designated constraints aren't met.
type ConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigValidationError) ErrorName() string { return "ConfigValidationError" }

// Error satisfies the builtin error interface
func (e ConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigValidationError{}

// Validate checks the field values on VersionedConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VersionedConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VersionedConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VersionedConfigMultiError, or nil if none found.
func (m *VersionedConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *VersionedConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VersionedConfigValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VersionedConfigValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VersionedConfigValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetConditions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VersionedConfigValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VersionedConfigValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VersionedConfigValidationError{
					field:  fmt.Sprintf("Conditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return VersionedConfigMultiError(errors)
	}

	return nil
}

// VersionedConfigMultiError is an error wrapping multiple validation errors
// returned by VersionedConfig.ValidateAll() if the designated constraints
// aren't met.
type VersionedConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VersionedConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VersionedConfigMultiError) AllErrors() []error { return m }

// VersionedConfigValidationError is the validation error returned by
// VersionedConfig.Validate if the designated constraints aren't met.
type VersionedConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VersionedConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VersionedConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VersionedConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VersionedConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VersionedConfigValidationError) ErrorName() string { return "VersionedConfigValidationError" }

// Error satisfies the builtin error interface
func (e VersionedConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVersionedConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VersionedConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VersionedConfigValidationError{}

// Validate checks the field values on RouteRewriteHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RouteRewriteHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RouteRewriteHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RouteRewriteHeaderMultiError, or nil if none found.
func (m *RouteRewriteHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *RouteRewriteHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Header

	// no validation rules for Value

	switch v := m.Matcher.(type) {
	case *RouteRewriteHeader_Prefix:
		if v == nil {
			err := RouteRewriteHeaderValidationError{
				field:  "Matcher",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Prefix
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RouteRewriteHeaderMultiError(errors)
	}

	return nil
}

// RouteRewriteHeaderMultiError is an error wrapping multiple validation errors
// returned by RouteRewriteHeader.ValidateAll() if the designated constraints
// aren't met.
type RouteRewriteHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RouteRewriteHeaderMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RouteRewriteHeaderMultiError) AllErrors() []error { return m }

// RouteRewriteHeaderValidationError is the validation error returned by
// RouteRewriteHeader.Validate if the designated constraints aren't met.
type RouteRewriteHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RouteRewriteHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RouteRewriteHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RouteRewriteHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RouteRewriteHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RouteRewriteHeaderValidationError) ErrorName() string {
	return "RouteRewriteHeaderValidationError"
}

// Error satisfies the builtin error interface
func (e RouteRewriteHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRouteRewriteHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RouteRewriteHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RouteRewriteHeaderValidationError{}

// Validate checks the field values on RouteRedirect with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RouteRedirect) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RouteRedirect with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RouteRedirectMultiError, or
// nil if none found.
func (m *RouteRedirect) ValidateAll() error {
	return m.validate(true)
}

func (m *RouteRedirect) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.HttpsRedirect != nil {
		// no validation rules for HttpsRedirect
	}

	if m.SchemeRedirect != nil {
		// no validation rules for SchemeRedirect
	}

	if m.HostRedirect != nil {
		// no validation rules for HostRedirect
	}

	if m.PortRedirect != nil {
		// no validation rules for PortRedirect
	}

	if m.PathRedirect != nil {
		// no validation rules for PathRedirect
	}

	if m.PrefixRewrite != nil {
		// no validation rules for PrefixRewrite
	}

	if m.ResponseCode != nil {
		// no validation rules for ResponseCode
	}

	if m.StripQuery != nil {
		// no validation rules for StripQuery
	}

	if len(errors) > 0 {
		return RouteRedirectMultiError(errors)
	}

	return nil
}

// RouteRedirectMultiError is an error wrapping multiple validation errors
// returned by RouteRedirect.ValidateAll() if the designated constraints
// aren't met.
type RouteRedirectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RouteRedirectMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RouteRedirectMultiError) AllErrors() []error { return m }

// RouteRedirectValidationError is the validation error returned by
// RouteRedirect.Validate if the designated constraints aren't met.
type RouteRedirectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RouteRedirectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RouteRedirectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RouteRedirectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RouteRedirectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RouteRedirectValidationError) ErrorName() string { return "RouteRedirectValidationError" }

// Error satisfies the builtin error interface
func (e RouteRedirectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRouteRedirect.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RouteRedirectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RouteRedirectValidationError{}

// Validate checks the field values on RouteDirectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RouteDirectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RouteDirectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RouteDirectResponseMultiError, or nil if none found.
func (m *RouteDirectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RouteDirectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Body

	if len(errors) > 0 {
		return RouteDirectResponseMultiError(errors)
	}

	return nil
}

// RouteDirectResponseMultiError is an error wrapping multiple validation
// errors returned by RouteDirectResponse.ValidateAll() if the designated
// constraints aren't met.
type RouteDirectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RouteDirectResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RouteDirectResponseMultiError) AllErrors() []error { return m }

// RouteDirectResponseValidationError is the validation error returned by
// RouteDirectResponse.Validate if the designated constraints aren't met.
type RouteDirectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RouteDirectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RouteDirectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RouteDirectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RouteDirectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RouteDirectResponseValidationError) ErrorName() string {
	return "RouteDirectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RouteDirectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRouteDirectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RouteDirectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RouteDirectResponseValidationError{}

// Validate checks the field values on CircuitBreakerThresholds with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CircuitBreakerThresholds) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CircuitBreakerThresholds with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CircuitBreakerThresholdsMultiError, or nil if none found.
func (m *CircuitBreakerThresholds) ValidateAll() error {
	return m.validate(true)
}

func (m *CircuitBreakerThresholds) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.MaxConnections != nil {
		// no validation rules for MaxConnections
	}

	if m.MaxPendingRequests != nil {
		// no validation rules for MaxPendingRequests
	}

	if m.MaxRequests != nil {
		// no validation rules for MaxRequests
	}

	if m.MaxRetries != nil {
		// no validation rules for MaxRetries
	}

	if m.MaxConnectionPools != nil {
		// no validation rules for MaxConnectionPools
	}

	if len(errors) > 0 {
		return CircuitBreakerThresholdsMultiError(errors)
	}

	return nil
}

// CircuitBreakerThresholdsMultiError is an error wrapping multiple validation
// errors returned by CircuitBreakerThresholds.ValidateAll() if the designated
// constraints aren't met.
type CircuitBreakerThresholdsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CircuitBreakerThresholdsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CircuitBreakerThresholdsMultiError) AllErrors() []error { return m }

// CircuitBreakerThresholdsValidationError is the validation error returned by
// CircuitBreakerThresholds.Validate if the designated constraints aren't met.
type CircuitBreakerThresholdsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CircuitBreakerThresholdsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CircuitBreakerThresholdsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CircuitBreakerThresholdsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CircuitBreakerThresholdsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CircuitBreakerThresholdsValidationError) ErrorName() string {
	return "CircuitBreakerThresholdsValidationError"
}

// Error satisfies the builtin error interface
func (e CircuitBreakerThresholdsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCircuitBreakerThresholds.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CircuitBreakerThresholdsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CircuitBreakerThresholdsValidationError{}

// Validate checks the field values on Route with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Route) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Route with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RouteMultiError, or nil if none found.
func (m *Route) ValidateAll() error {
	return m.validate(true)
}

func (m *Route) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	if all {
		switch v := interface{}(m.GetRedirect()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RouteValidationError{
					field:  "Redirect",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RouteValidationError{
					field:  "Redirect",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRedirect()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RouteValidationError{
				field:  "Redirect",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RouteValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RouteValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RouteValidationError{
				field:  "Response",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetAllowedIdpClaims()))
		i := 0
		for key := range m.GetAllowedIdpClaims() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetAllowedIdpClaims()[key]
			_ = val

			// no validation rules for AllowedIdpClaims[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, RouteValidationError{
							field:  fmt.Sprintf("AllowedIdpClaims[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, RouteValidationError{
							field:  fmt.Sprintf("AllowedIdpClaims[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return RouteValidationError{
						field:  fmt.Sprintf("AllowedIdpClaims[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Prefix

	// no validation rules for Path

	// no validation rules for Regex

	// no validation rules for PrefixRewrite

	// no validation rules for RegexRewritePattern

	// no validation rules for RegexRewriteSubstitution

	// no validation rules for CorsAllowPreflight

	// no validation rules for AllowPublicUnauthenticatedAccess

	// no validation rules for AllowAnyAuthenticatedUser

	if all {
		switch v := interface{}(m.GetTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RouteValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RouteValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RouteValidationError{
				field:  "Timeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIdleTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RouteValidationError{
					field:  "IdleTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RouteValidationError{
					field:  "IdleTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdleTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RouteValidationError{
				field:  "IdleTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AllowWebsockets

	// no validation rules for AllowSpdy

	// no validation rules for TlsSkipVerify

	// no validation rules for TlsServerName

	// no validation rules for TlsUpstreamServerName

	// no validation rules for TlsDownstreamServerName

	// no validation rules for TlsCustomCa

	// no validation rules for TlsCustomCaFile

	// no validation rules for TlsClientCert

	// no validation rules for TlsClientKey

	// no validation rules for TlsClientCertFile

	// no validation rules for TlsClientKeyFile

	// no validation rules for TlsDownstreamClientCa

	// no validation rules for TlsDownstreamClientCaFile

	// no validation rules for TlsUpstreamAllowRenegotiation

	// no validation rules for SetRequestHeaders

	// no validation rules for SetResponseHeaders

	for idx, item := range m.GetRewriteResponseHeaders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  fmt.Sprintf("RewriteResponseHeaders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  fmt.Sprintf("RewriteResponseHeaders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RouteValidationError{
					field:  fmt.Sprintf("RewriteResponseHeaders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PreserveHostHeader

	// no validation rules for KubernetesServiceAccountToken

	// no validation rules for KubernetesServiceAccountTokenFile

	// no validation rules for EnableGoogleCloudServerlessAuthentication

	for idx, item := range m.GetPolicies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  fmt.Sprintf("Policies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  fmt.Sprintf("Policies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RouteValidationError{
					field:  fmt.Sprintf("Policies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPplPolicies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  fmt.Sprintf("PplPolicies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  fmt.Sprintf("PplPolicies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RouteValidationError{
					field:  fmt.Sprintf("PplPolicies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ShowErrorDetails

	for idx, item := range m.GetHealthChecks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  fmt.Sprintf("HealthChecks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  fmt.Sprintf("HealthChecks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RouteValidationError{
					field:  fmt.Sprintf("HealthChecks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RouteValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RouteValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RouteValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RouteValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RouteValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RouteValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.NamespaceId != nil {
		// no validation rules for NamespaceId
	}

	if m.OriginatorId != nil {
		// no validation rules for OriginatorId
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.StatName != nil {
		// no validation rules for StatName
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.LogoUrl != nil {
		// no validation rules for LogoUrl
	}

	if m.RegexPriorityOrder != nil {
		// no validation rules for RegexPriorityOrder
	}

	if m.TlsCustomCaKeyPairId != nil {
		// no validation rules for TlsCustomCaKeyPairId
	}

	if m.TlsClientKeyPairId != nil {
		// no validation rules for TlsClientKeyPairId
	}

	if m.TlsDownstreamClientCaKeyPairId != nil {
		// no validation rules for TlsDownstreamClientCaKeyPairId
	}

	if m.PassIdentityHeaders != nil {
		// no validation rules for PassIdentityHeaders
	}

	if m.KubernetesServiceAccountTokenKeyPairId != nil {
		// no validation rules for KubernetesServiceAccountTokenKeyPairId
	}

	if m.JwtIssuerFormat != nil {
		// no validation rules for JwtIssuerFormat
	}

	if m.BearerTokenFormat != nil {
		// no validation rules for BearerTokenFormat
	}

	if m.HostRewrite != nil {
		// no validation rules for HostRewrite
	}

	if m.HostRewriteHeader != nil {
		// no validation rules for HostRewriteHeader
	}

	if m.HostPathRegexRewritePattern != nil {
		// no validation rules for HostPathRegexRewritePattern
	}

	if m.HostPathRegexRewriteSubstitution != nil {
		// no validation rules for HostPathRegexRewriteSubstitution
	}

	if m.IdpClientId != nil {
		// no validation rules for IdpClientId
	}

	if m.IdpClientSecret != nil {
		// no validation rules for IdpClientSecret
	}

	if m.IdpAccessTokenAllowedAudiences != nil {

		if all {
			switch v := interface{}(m.GetIdpAccessTokenAllowedAudiences()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  "IdpAccessTokenAllowedAudiences",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  "IdpAccessTokenAllowedAudiences",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIdpAccessTokenAllowedAudiences()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RouteValidationError{
					field:  "IdpAccessTokenAllowedAudiences",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Mcp != nil {

		if all {
			switch v := interface{}(m.GetMcp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  "Mcp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  "Mcp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMcp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RouteValidationError{
					field:  "Mcp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CircuitBreakerThresholds != nil {

		if all {
			switch v := interface{}(m.GetCircuitBreakerThresholds()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  "CircuitBreakerThresholds",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  "CircuitBreakerThresholds",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCircuitBreakerThresholds()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RouteValidationError{
					field:  "CircuitBreakerThresholds",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpstreamTunnel != nil {

		if all {
			switch v := interface{}(m.GetUpstreamTunnel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  "UpstreamTunnel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  "UpstreamTunnel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpstreamTunnel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RouteValidationError{
					field:  "UpstreamTunnel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.OutlierDetection != nil {

		if all {
			switch v := interface{}(m.GetOutlierDetection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  "OutlierDetection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RouteValidationError{
						field:  "OutlierDetection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOutlierDetection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RouteValidationError{
					field:  "OutlierDetection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.LoadBalancingPolicy != nil {
		// no validation rules for LoadBalancingPolicy
	}

	if m.HealthyPanicThreshold != nil {
		// no validation rules for HealthyPanicThreshold
	}

	if len(errors) > 0 {
		return RouteMultiError(errors)
	}

	return nil
}

// RouteMultiError is an error wrapping multiple validation errors returned by
// Route.ValidateAll() if the designated constraints aren't met.
type RouteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RouteMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RouteMultiError) AllErrors() []error { return m }

// RouteValidationError is the validation error returned by Route.Validate if
// the designated constraints aren't met.
type RouteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RouteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RouteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RouteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RouteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RouteValidationError) ErrorName() string { return "RouteValidationError" }

// Error satisfies the builtin error interface
func (e RouteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoute.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RouteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RouteValidationError{}

// Validate checks the field values on UpstreamTunnel with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpstreamTunnel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpstreamTunnel with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpstreamTunnelMultiError,
// or nil if none found.
func (m *UpstreamTunnel) ValidateAll() error {
	return m.validate(true)
}

func (m *UpstreamTunnel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpstreamTunnelMultiError(errors)
	}

	return nil
}

// UpstreamTunnelMultiError is an error wrapping multiple validation errors
// returned by UpstreamTunnel.ValidateAll() if the designated constraints
// aren't met.
type UpstreamTunnelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpstreamTunnelMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpstreamTunnelMultiError) AllErrors() []error { return m }

// UpstreamTunnelValidationError is the validation error returned by
// UpstreamTunnel.Validate if the designated constraints aren't met.
type UpstreamTunnelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpstreamTunnelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpstreamTunnelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpstreamTunnelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpstreamTunnelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpstreamTunnelValidationError) ErrorName() string { return "UpstreamTunnelValidationError" }

// Error satisfies the builtin error interface
func (e UpstreamTunnelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpstreamTunnel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpstreamTunnelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpstreamTunnelValidationError{}

// Validate checks the field values on MCP with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *MCP) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MCP with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MCPMultiError, or nil if none found.
func (m *MCP) ValidateAll() error {
	return m.validate(true)
}

func (m *MCP) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Mode.(type) {
	case *MCP_Server:
		if v == nil {
			err := MCPValidationError{
				field:  "Mode",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetServer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MCPValidationError{
						field:  "Server",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MCPValidationError{
						field:  "Server",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MCPValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MCP_Client:
		if v == nil {
			err := MCPValidationError{
				field:  "Mode",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetClient()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MCPValidationError{
						field:  "Client",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MCPValidationError{
						field:  "Client",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetClient()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MCPValidationError{
					field:  "Client",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return MCPMultiError(errors)
	}

	return nil
}

// MCPMultiError is an error wrapping multiple validation errors returned by
// MCP.ValidateAll() if the designated constraints aren't met.
type MCPMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MCPMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MCPMultiError) AllErrors() []error { return m }

// MCPValidationError is the validation error returned by MCP.Validate if the
// designated constraints aren't met.
type MCPValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MCPValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MCPValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MCPValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MCPValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MCPValidationError) ErrorName() string { return "MCPValidationError" }

// Error satisfies the builtin error interface
func (e MCPValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMCP.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MCPValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MCPValidationError{}

// Validate checks the field values on MCPServer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MCPServer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MCPServer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MCPServerMultiError, or nil
// if none found.
func (m *MCPServer) ValidateAll() error {
	return m.validate(true)
}

func (m *MCPServer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.UpstreamOauth2 != nil {

		if all {
			switch v := interface{}(m.GetUpstreamOauth2()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MCPServerValidationError{
						field:  "UpstreamOauth2",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MCPServerValidationError{
						field:  "UpstreamOauth2",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpstreamOauth2()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MCPServerValidationError{
					field:  "UpstreamOauth2",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.MaxRequestBytes != nil {
		// no validation rules for MaxRequestBytes
	}

	if m.Path != nil {
		// no validation rules for Path
	}

	if len(errors) > 0 {
		return MCPServerMultiError(errors)
	}

	return nil
}

// MCPServerMultiError is an error wrapping multiple validation errors returned
// by MCPServer.ValidateAll() if the designated constraints aren't met.
type MCPServerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MCPServerMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MCPServerMultiError) AllErrors() []error { return m }

// MCPServerValidationError is the validation error returned by
// MCPServer.Validate if the designated constraints aren't met.
type MCPServerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MCPServerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MCPServerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MCPServerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MCPServerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MCPServerValidationError) ErrorName() string { return "MCPServerValidationError" }

// Error satisfies the builtin error interface
func (e MCPServerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMCPServer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MCPServerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MCPServerValidationError{}

// Validate checks the field values on MCPClient with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MCPClient) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MCPClient with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MCPClientMultiError, or nil
// if none found.
func (m *MCPClient) ValidateAll() error {
	return m.validate(true)
}

func (m *MCPClient) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MCPClientMultiError(errors)
	}

	return nil
}

// MCPClientMultiError is an error wrapping multiple validation errors returned
// by MCPClient.ValidateAll() if the designated constraints aren't met.
type MCPClientMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MCPClientMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MCPClientMultiError) AllErrors() []error { return m }

// MCPClientValidationError is the validation error returned by
// MCPClient.Validate if the designated constraints aren't met.
type MCPClientValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MCPClientValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MCPClientValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MCPClientValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MCPClientValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MCPClientValidationError) ErrorName() string { return "MCPClientValidationError" }

// Error satisfies the builtin error interface
func (e MCPClientValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMCPClient.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MCPClientValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MCPClientValidationError{}

// Validate checks the field values on UpstreamOAuth2 with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpstreamOAuth2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpstreamOAuth2 with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpstreamOAuth2MultiError,
// or nil if none found.
func (m *UpstreamOAuth2) ValidateAll() error {
	return m.validate(true)
}

func (m *UpstreamOAuth2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClientId

	// no validation rules for ClientSecret

	if all {
		switch v := interface{}(m.GetOauth2Endpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpstreamOAuth2ValidationError{
					field:  "Oauth2Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpstreamOAuth2ValidationError{
					field:  "Oauth2Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOauth2Endpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpstreamOAuth2ValidationError{
				field:  "Oauth2Endpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpstreamOAuth2MultiError(errors)
	}

	return nil
}

// UpstreamOAuth2MultiError is an error wrapping multiple validation errors
// returned by UpstreamOAuth2.ValidateAll() if the designated constraints
// aren't met.
type UpstreamOAuth2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpstreamOAuth2MultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpstreamOAuth2MultiError) AllErrors() []error { return m }

// UpstreamOAuth2ValidationError is the validation error returned by
// UpstreamOAuth2.Validate if the designated constraints aren't met.
type UpstreamOAuth2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpstreamOAuth2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpstreamOAuth2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpstreamOAuth2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpstreamOAuth2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpstreamOAuth2ValidationError) ErrorName() string { return "UpstreamOAuth2ValidationError" }

// Error satisfies the builtin error interface
func (e UpstreamOAuth2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpstreamOAuth2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpstreamOAuth2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpstreamOAuth2ValidationError{}

// Validate checks the field values on OAuth2Endpoint with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OAuth2Endpoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2Endpoint with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OAuth2EndpointMultiError,
// or nil if none found.
func (m *OAuth2Endpoint) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2Endpoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthUrl

	// no validation rules for TokenUrl

	if m.AuthStyle != nil {
		// no validation rules for AuthStyle
	}

	if len(errors) > 0 {
		return OAuth2EndpointMultiError(errors)
	}

	return nil
}

// OAuth2EndpointMultiError is an error wrapping multiple validation errors
// returned by OAuth2Endpoint.ValidateAll() if the designated constraints
// aren't met.
type OAuth2EndpointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2EndpointMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2EndpointMultiError) AllErrors() []error { return m }

// OAuth2EndpointValidationError is the validation error returned by
// OAuth2Endpoint.Validate if the designated constraints aren't met.
type OAuth2EndpointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2EndpointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2EndpointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2EndpointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2EndpointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2EndpointValidationError) ErrorName() string { return "OAuth2EndpointValidationError" }

// Error satisfies the builtin error interface
func (e OAuth2EndpointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2Endpoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2EndpointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2EndpointValidationError{}

// Validate checks the field values on PPLPolicy with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PPLPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PPLPolicy with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PPLPolicyMultiError, or nil
// if none found.
func (m *PPLPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *PPLPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Raw

	if len(errors) > 0 {
		return PPLPolicyMultiError(errors)
	}

	return nil
}

// PPLPolicyMultiError is an error wrapping multiple validation errors returned
// by PPLPolicy.ValidateAll() if the designated constraints aren't met.
type PPLPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PPLPolicyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PPLPolicyMultiError) AllErrors() []error { return m }

// PPLPolicyValidationError is the validation error returned by
// PPLPolicy.Validate if the designated constraints aren't met.
type PPLPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PPLPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PPLPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PPLPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PPLPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PPLPolicyValidationError) ErrorName() string { return "PPLPolicyValidationError" }

// Error satisfies the builtin error interface
func (e PPLPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPPLPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PPLPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PPLPolicyValidationError{}

// Validate checks the field values on Policy with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Policy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Policy with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PolicyMultiError, or nil if none found.
func (m *Policy) ValidateAll() error {
	return m.validate(true)
}

func (m *Policy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetAllowedIdpClaims()))
		i := 0
		for key := range m.GetAllowedIdpClaims() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetAllowedIdpClaims()[key]
			_ = val

			// no validation rules for AllowedIdpClaims[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, PolicyValidationError{
							field:  fmt.Sprintf("AllowedIdpClaims[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, PolicyValidationError{
							field:  fmt.Sprintf("AllowedIdpClaims[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return PolicyValidationError{
						field:  fmt.Sprintf("AllowedIdpClaims[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PolicyValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PolicyValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.NamespaceId != nil {
		// no validation rules for NamespaceId
	}

	if m.OriginatorId != nil {
		// no validation rules for OriginatorId
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Enforced != nil {
		// no validation rules for Enforced
	}

	if m.SourcePpl != nil {
		// no validation rules for SourcePpl
	}

	if m.Explanation != nil {
		// no validation rules for Explanation
	}

	if m.Remediation != nil {
		// no validation rules for Remediation
	}

	if len(errors) > 0 {
		return PolicyMultiError(errors)
	}

	return nil
}

// PolicyMultiError is an error wrapping multiple validation errors returned by
// Policy.ValidateAll() if the designated constraints aren't met.
type PolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolicyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolicyMultiError) AllErrors() []error { return m }

// PolicyValidationError is the validation error returned by Policy.Validate if
// the designated constraints aren't met.
type PolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolicyValidationError) ErrorName() string { return "PolicyValidationError" }

// Error satisfies the builtin error interface
func (e PolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolicyValidationError{}

// Validate checks the field values on Settings with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Settings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Settings with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SettingsMultiError, or nil
// if none found.
func (m *Settings) ValidateAll() error {
	return m.validate(true)
}

func (m *Settings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCertificates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  fmt.Sprintf("Certificates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  fmt.Sprintf("Certificates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  fmt.Sprintf("Certificates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestParams

	// no validation rules for SetResponseHeaders

	// no validation rules for JwtClaimsHeaders

	// no validation rules for RuntimeFlags

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SettingsValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SettingsValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.NamespaceId != nil {
		// no validation rules for NamespaceId
	}

	if m.OriginatorId != nil {
		// no validation rules for OriginatorId
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.InstallationId != nil {
		// no validation rules for InstallationId
	}

	if m.LogLevel != nil {
		// no validation rules for LogLevel
	}

	if m.AccessLogFields != nil {

		if all {
			switch v := interface{}(m.GetAccessLogFields()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "AccessLogFields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "AccessLogFields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAccessLogFields()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "AccessLogFields",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.AuthorizeLogFields != nil {

		if all {
			switch v := interface{}(m.GetAuthorizeLogFields()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "AuthorizeLogFields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "AuthorizeLogFields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthorizeLogFields()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "AuthorizeLogFields",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.ProxyLogLevel != nil {
		// no validation rules for ProxyLogLevel
	}

	if m.SharedSecret != nil {
		// no validation rules for SharedSecret
	}

	if m.Services != nil {
		// no validation rules for Services
	}

	if m.Address != nil {
		// no validation rules for Address
	}

	if m.InsecureServer != nil {
		// no validation rules for InsecureServer
	}

	if m.DnsFailureRefreshRate != nil {

		if all {
			switch v := interface{}(m.GetDnsFailureRefreshRate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "DnsFailureRefreshRate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "DnsFailureRefreshRate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDnsFailureRefreshRate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "DnsFailureRefreshRate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.DnsLookupFamily != nil {
		// no validation rules for DnsLookupFamily
	}

	if m.DnsQueryTimeout != nil {

		if all {
			switch v := interface{}(m.GetDnsQueryTimeout()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "DnsQueryTimeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "DnsQueryTimeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDnsQueryTimeout()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "DnsQueryTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.DnsQueryTries != nil {
		// no validation rules for DnsQueryTries
	}

	if m.DnsRefreshRate != nil {

		if all {
			switch v := interface{}(m.GetDnsRefreshRate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "DnsRefreshRate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "DnsRefreshRate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDnsRefreshRate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "DnsRefreshRate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.DnsUdpMaxQueries != nil {
		// no validation rules for DnsUdpMaxQueries
	}

	if m.DnsUseTcp != nil {
		// no validation rules for DnsUseTcp
	}

	if m.HttpRedirectAddr != nil {
		// no validation rules for HttpRedirectAddr
	}

	if m.TimeoutRead != nil {

		if all {
			switch v := interface{}(m.GetTimeoutRead()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "TimeoutRead",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "TimeoutRead",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimeoutRead()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "TimeoutRead",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.TimeoutWrite != nil {

		if all {
			switch v := interface{}(m.GetTimeoutWrite()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "TimeoutWrite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "TimeoutWrite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimeoutWrite()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "TimeoutWrite",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.TimeoutIdle != nil {

		if all {
			switch v := interface{}(m.GetTimeoutIdle()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "TimeoutIdle",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "TimeoutIdle",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimeoutIdle()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "TimeoutIdle",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.AuthenticateServiceUrl != nil {
		// no validation rules for AuthenticateServiceUrl
	}

	if m.AuthenticateInternalServiceUrl != nil {
		// no validation rules for AuthenticateInternalServiceUrl
	}

	if m.SignoutRedirectUrl != nil {
		// no validation rules for SignoutRedirectUrl
	}

	if m.CookieName != nil {
		// no validation rules for CookieName
	}

	if m.CookieSecret != nil {
		// no validation rules for CookieSecret
	}

	if m.CookieDomain != nil {
		// no validation rules for CookieDomain
	}

	if m.CookieHttpOnly != nil {
		// no validation rules for CookieHttpOnly
	}

	if m.CookieExpire != nil {

		if all {
			switch v := interface{}(m.GetCookieExpire()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "CookieExpire",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "CookieExpire",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCookieExpire()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "CookieExpire",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CookieSameSite != nil {
		// no validation rules for CookieSameSite
	}

	if m.IdpClientId != nil {
		// no validation rules for IdpClientId
	}

	if m.IdpClientSecret != nil {
		// no validation rules for IdpClientSecret
	}

	if m.IdpProvider != nil {
		// no validation rules for IdpProvider
	}

	if m.IdpProviderUrl != nil {
		// no validation rules for IdpProviderUrl
	}

	if m.IdpAccessTokenAllowedAudiences != nil {

		if all {
			switch v := interface{}(m.GetIdpAccessTokenAllowedAudiences()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "IdpAccessTokenAllowedAudiences",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "IdpAccessTokenAllowedAudiences",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIdpAccessTokenAllowedAudiences()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "IdpAccessTokenAllowedAudiences",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.AuthorizeInternalServiceUrl != nil {
		// no validation rules for AuthorizeInternalServiceUrl
	}

	if m.OverrideCertificateName != nil {
		// no validation rules for OverrideCertificateName
	}

	if m.CertificateAuthority != nil {
		// no validation rules for CertificateAuthority
	}

	if m.CertificateAuthorityKeyPairId != nil {
		// no validation rules for CertificateAuthorityKeyPairId
	}

	if m.DeriveTls != nil {
		// no validation rules for DeriveTls
	}

	if m.SigningKey != nil {
		// no validation rules for SigningKey
	}

	if m.JwtIssuerFormat != nil {
		// no validation rules for JwtIssuerFormat
	}

	if m.BearerTokenFormat != nil {
		// no validation rules for BearerTokenFormat
	}

	if m.DefaultUpstreamTimeout != nil {

		if all {
			switch v := interface{}(m.GetDefaultUpstreamTimeout()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "DefaultUpstreamTimeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "DefaultUpstreamTimeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDefaultUpstreamTimeout()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "DefaultUpstreamTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.DebugAddress != nil {
		// no validation rules for DebugAddress
	}

	if m.MetricsAddress != nil {
		// no validation rules for MetricsAddress
	}

	if m.MetricsBasicAuth != nil {
		// no validation rules for MetricsBasicAuth
	}

	if m.MetricsCertificate != nil {

		if all {
			switch v := interface{}(m.GetMetricsCertificate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "MetricsCertificate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "MetricsCertificate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsCertificate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "MetricsCertificate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.MetricsClientCa != nil {
		// no validation rules for MetricsClientCa
	}

	if m.MetricsClientCaKeyPairId != nil {
		// no validation rules for MetricsClientCaKeyPairId
	}

	if m.OtelTracesExporter != nil {
		// no validation rules for OtelTracesExporter
	}

	if m.OtelTracesSamplerArg != nil {
		// no validation rules for OtelTracesSamplerArg
	}

	if m.OtelLogLevel != nil {
		// no validation rules for OtelLogLevel
	}

	if m.OtelAttributeValueLengthLimit != nil {
		// no validation rules for OtelAttributeValueLengthLimit
	}

	if m.OtelExporterOtlpEndpoint != nil {
		// no validation rules for OtelExporterOtlpEndpoint
	}

	if m.OtelExporterOtlpTracesEndpoint != nil {
		// no validation rules for OtelExporterOtlpTracesEndpoint
	}

	if m.OtelExporterOtlpProtocol != nil {
		// no validation rules for OtelExporterOtlpProtocol
	}

	if m.OtelExporterOtlpTracesProtocol != nil {
		// no validation rules for OtelExporterOtlpTracesProtocol
	}

	if m.OtelExporterOtlpTimeout != nil {

		if all {
			switch v := interface{}(m.GetOtelExporterOtlpTimeout()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "OtelExporterOtlpTimeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "OtelExporterOtlpTimeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOtelExporterOtlpTimeout()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "OtelExporterOtlpTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.OtelExporterOtlpTracesTimeout != nil {

		if all {
			switch v := interface{}(m.GetOtelExporterOtlpTracesTimeout()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "OtelExporterOtlpTracesTimeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "OtelExporterOtlpTracesTimeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOtelExporterOtlpTracesTimeout()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "OtelExporterOtlpTracesTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.OtelBspScheduleDelay != nil {

		if all {
			switch v := interface{}(m.GetOtelBspScheduleDelay()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "OtelBspScheduleDelay",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "OtelBspScheduleDelay",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOtelBspScheduleDelay()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "OtelBspScheduleDelay",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.OtelBspMaxExportBatchSize != nil {
		// no validation rules for OtelBspMaxExportBatchSize
	}

	if m.GrpcAddress != nil {
		// no validation rules for GrpcAddress
	}

	if m.GrpcInsecure != nil {
		// no validation rules for GrpcInsecure
	}

	if m.GrpcClientTimeout != nil {

		if all {
			switch v := interface{}(m.GetGrpcClientTimeout()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "GrpcClientTimeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "GrpcClientTimeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGrpcClientTimeout()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "GrpcClientTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.DatabrokerClusterLeaderId != nil {
		// no validation rules for DatabrokerClusterLeaderId
	}

	if m.DatabrokerClusterNodeId != nil {
		// no validation rules for DatabrokerClusterNodeId
	}

	if m.DatabrokerClusterNodes != nil {

		if all {
			switch v := interface{}(m.GetDatabrokerClusterNodes()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "DatabrokerClusterNodes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "DatabrokerClusterNodes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatabrokerClusterNodes()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "DatabrokerClusterNodes",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.DatabrokerInternalServiceUrl != nil {
		// no validation rules for DatabrokerInternalServiceUrl
	}

	if m.DatabrokerRaftBindAddress != nil {
		// no validation rules for DatabrokerRaftBindAddress
	}

	if m.DatabrokerStorageType != nil {
		// no validation rules for DatabrokerStorageType
	}

	if m.DatabrokerStorageConnectionString != nil {
		// no validation rules for DatabrokerStorageConnectionString
	}

	if m.DownstreamMtls != nil {

		if all {
			switch v := interface{}(m.GetDownstreamMtls()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "DownstreamMtls",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "DownstreamMtls",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDownstreamMtls()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "DownstreamMtls",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GoogleCloudServerlessAuthenticationServiceAccount != nil {
		// no validation rules for GoogleCloudServerlessAuthenticationServiceAccount
	}

	if m.UseProxyProtocol != nil {
		// no validation rules for UseProxyProtocol
	}

	if m.Autocert != nil {
		// no validation rules for Autocert
	}

	if m.AutocertCa != nil {
		// no validation rules for AutocertCa
	}

	if m.AutocertCaKeyPairId != nil {
		// no validation rules for AutocertCaKeyPairId
	}

	if m.AutocertEmail != nil {
		// no validation rules for AutocertEmail
	}

	if m.AutocertUseStaging != nil {
		// no validation rules for AutocertUseStaging
	}

	if m.AutocertEabKeyId != nil {
		// no validation rules for AutocertEabKeyId
	}

	if m.AutocertEabMacKey != nil {
		// no validation rules for AutocertEabMacKey
	}

	if m.AutocertMustStaple != nil {
		// no validation rules for AutocertMustStaple
	}

	if m.AutocertDir != nil {
		// no validation rules for AutocertDir
	}

	if m.AutocertTrustedCa != nil {
		// no validation rules for AutocertTrustedCa
	}

	if m.AutocertTrustedCaKeyPairId != nil {
		// no validation rules for AutocertTrustedCaKeyPairId
	}

	if m.SkipXffAppend != nil {
		// no validation rules for SkipXffAppend
	}

	if m.XffNumTrustedHops != nil {
		// no validation rules for XffNumTrustedHops
	}

	if m.EnvoyAdminAccessLogPath != nil {
		// no validation rules for EnvoyAdminAccessLogPath
	}

	if m.EnvoyAdminProfilePath != nil {
		// no validation rules for EnvoyAdminProfilePath
	}

	if m.EnvoyAdminAddress != nil {
		// no validation rules for EnvoyAdminAddress
	}

	if m.EnvoyBindConfigSourceAddress != nil {
		// no validation rules for EnvoyBindConfigSourceAddress
	}

	if m.EnvoyBindConfigFreebind != nil {
		// no validation rules for EnvoyBindConfigFreebind
	}

	if m.CodecType != nil {
		// no validation rules for CodecType
	}

	if m.PrimaryColor != nil {
		// no validation rules for PrimaryColor
	}

	if m.SecondaryColor != nil {
		// no validation rules for SecondaryColor
	}

	if m.DarkmodePrimaryColor != nil {
		// no validation rules for DarkmodePrimaryColor
	}

	if m.DarkmodeSecondaryColor != nil {
		// no validation rules for DarkmodeSecondaryColor
	}

	if m.LogoUrl != nil {
		// no validation rules for LogoUrl
	}

	if m.FaviconUrl != nil {
		// no validation rules for FaviconUrl
	}

	if m.ErrorMessageFirstParagraph != nil {
		// no validation rules for ErrorMessageFirstParagraph
	}

	if m.PassIdentityHeaders != nil {
		// no validation rules for PassIdentityHeaders
	}

	if m.Http3AdvertisePort != nil {
		// no validation rules for Http3AdvertisePort
	}

	if m.CircuitBreakerThresholds != nil {

		if all {
			switch v := interface{}(m.GetCircuitBreakerThresholds()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "CircuitBreakerThresholds",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "CircuitBreakerThresholds",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCircuitBreakerThresholds()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "CircuitBreakerThresholds",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.SshAddress != nil {
		// no validation rules for SshAddress
	}

	if m.SshHostKeyFiles != nil {

		if all {
			switch v := interface{}(m.GetSshHostKeyFiles()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "SshHostKeyFiles",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "SshHostKeyFiles",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSshHostKeyFiles()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "SshHostKeyFiles",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.SshHostKeys != nil {

		if all {
			switch v := interface{}(m.GetSshHostKeys()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "SshHostKeys",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SettingsValidationError{
						field:  "SshHostKeys",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSshHostKeys()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SettingsValidationError{
					field:  "SshHostKeys",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.SshUserCaKeyFile != nil {
		// no validation rules for SshUserCaKeyFile
	}

	if m.SshUserCaKey != nil {
		// no validation rules for SshUserCaKey
	}

	if m.SshUserCaKeyPairId != nil {
		// no validation rules for SshUserCaKeyPairId
	}

	if len(errors) > 0 {
		return SettingsMultiError(errors)
	}

	return nil
}

// SettingsMultiError is an error wrapping multiple validation errors returned
// by Settings.ValidateAll() if the designated constraints aren't met.
type SettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SettingsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SettingsMultiError) AllErrors() []error { return m }

// SettingsValidationError is the validation error returned by
// Settings.Validate if the designated constraints aren't met.
type SettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SettingsValidationError) ErrorName() string { return "SettingsValidationError" }

// Error satisfies the builtin error interface
func (e SettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SettingsValidationError{}

// Validate checks the field values on DownstreamMtlsSettings with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownstreamMtlsSettings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownstreamMtlsSettings with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownstreamMtlsSettingsMultiError, or nil if none found.
func (m *DownstreamMtlsSettings) ValidateAll() error {
	return m.validate(true)
}

func (m *DownstreamMtlsSettings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMatchSubjectAltNames() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownstreamMtlsSettingsValidationError{
						field:  fmt.Sprintf("MatchSubjectAltNames[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownstreamMtlsSettingsValidationError{
						field:  fmt.Sprintf("MatchSubjectAltNames[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownstreamMtlsSettingsValidationError{
					field:  fmt.Sprintf("MatchSubjectAltNames[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Ca != nil {
		// no validation rules for Ca
	}

	if m.Crl != nil {
		// no validation rules for Crl
	}

	if m.Enforcement != nil {
		// no validation rules for Enforcement
	}

	if m.MaxVerifyDepth != nil {
		// no validation rules for MaxVerifyDepth
	}

	if len(errors) > 0 {
		return DownstreamMtlsSettingsMultiError(errors)
	}

	return nil
}

// DownstreamMtlsSettingsMultiError is an error wrapping multiple validation
// errors returned by DownstreamMtlsSettings.ValidateAll() if the designated
// constraints aren't met.
type DownstreamMtlsSettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownstreamMtlsSettingsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownstreamMtlsSettingsMultiError) AllErrors() []error { return m }

// DownstreamMtlsSettingsValidationError is the validation error returned by
// DownstreamMtlsSettings.Validate if the designated constraints aren't met.
type DownstreamMtlsSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownstreamMtlsSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownstreamMtlsSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownstreamMtlsSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownstreamMtlsSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownstreamMtlsSettingsValidationError) ErrorName() string {
	return "DownstreamMtlsSettingsValidationError"
}

// Error satisfies the builtin error interface
func (e DownstreamMtlsSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownstreamMtlsSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownstreamMtlsSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownstreamMtlsSettingsValidationError{}

// Validate checks the field values on SANMatcher with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SANMatcher) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SANMatcher with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SANMatcherMultiError, or
// nil if none found.
func (m *SANMatcher) ValidateAll() error {
	return m.validate(true)
}

func (m *SANMatcher) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SanType

	// no validation rules for Pattern

	if len(errors) > 0 {
		return SANMatcherMultiError(errors)
	}

	return nil
}

// SANMatcherMultiError is an error wrapping multiple validation errors
// returned by SANMatcher.ValidateAll() if the designated constraints aren't met.
type SANMatcherMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SANMatcherMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SANMatcherMultiError) AllErrors() []error { return m }

// SANMatcherValidationError is the validation error returned by
// SANMatcher.Validate if the designated constraints aren't met.
type SANMatcherValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SANMatcherValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SANMatcherValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SANMatcherValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SANMatcherValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SANMatcherValidationError) ErrorName() string { return "SANMatcherValidationError" }

// Error satisfies the builtin error interface
func (e SANMatcherValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSANMatcher.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SANMatcherValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SANMatcherValidationError{}

// Validate checks the field values on KeyPair with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KeyPair) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyPair with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in KeyPairMultiError, or nil if none found.
func (m *KeyPair) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyPair) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyPairValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyPairValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyPairValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyPairValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyPairValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyPairValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	// no validation rules for Origin

	for idx, item := range m.GetCertificateInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KeyPairValidationError{
						field:  fmt.Sprintf("CertificateInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KeyPairValidationError{
						field:  fmt.Sprintf("CertificateInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KeyPairValidationError{
					field:  fmt.Sprintf("CertificateInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Id != nil {

		if utf8.RuneCountInString(m.GetId()) < 1 {
			err := KeyPairValidationError{
				field:  "Id",
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.NamespaceId != nil {

		if utf8.RuneCountInString(m.GetNamespaceId()) < 1 {
			err := KeyPairValidationError{
				field:  "NamespaceId",
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.OriginatorId != nil {

		if utf8.RuneCountInString(m.GetOriginatorId()) < 1 {
			err := KeyPairValidationError{
				field:  "OriginatorId",
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Name != nil {

		if utf8.RuneCountInString(m.GetName()) < 1 {
			err := KeyPairValidationError{
				field:  "Name",
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Certificate != nil {

		if len(m.GetCertificate()) < 1 {
			err := KeyPairValidationError{
				field:  "Certificate",
				reason: "value length must be at least 1 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Key != nil {

		if len(m.GetKey()) < 1 {
			err := KeyPairValidationError{
				field:  "Key",
				reason: "value length must be at least 1 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return KeyPairMultiError(errors)
	}

	return nil
}

// KeyPairMultiError is an error wrapping multiple validation errors returned
// by KeyPair.ValidateAll() if the designated constraints aren't met.
type KeyPairMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyPairMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyPairMultiError) AllErrors() []error { return m }

// KeyPairValidationError is the validation error returned by KeyPair.Validate
// if the designated constraints aren't met.
type KeyPairValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyPairValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyPairValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyPairValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyPairValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyPairValidationError) ErrorName() string { return "KeyPairValidationError" }

// Error satisfies the builtin error interface
func (e KeyPairValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyPair.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyPairValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyPairValidationError{}

// Validate checks the field values on KeyUsage with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KeyUsage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyUsage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KeyUsageMultiError, or nil
// if none found.
func (m *KeyUsage) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyUsage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DigitalSignature

	// no validation rules for ContentCommitment

	// no validation rules for KeyEncipherment

	// no validation rules for DataEncipherment

	// no validation rules for KeyAgreement

	// no validation rules for CertSign

	// no validation rules for CrlSign

	// no validation rules for EncipherOnly

	// no validation rules for DecipherOnly

	// no validation rules for ServerAuth

	// no validation rules for ClientAuth

	if len(errors) > 0 {
		return KeyUsageMultiError(errors)
	}

	return nil
}

// KeyUsageMultiError is an error wrapping multiple validation errors returned
// by KeyUsage.ValidateAll() if the designated constraints aren't met.
type KeyUsageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyUsageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyUsageMultiError) AllErrors() []error { return m }

// KeyUsageValidationError is the validation error returned by
// KeyUsage.Validate if the designated constraints aren't met.
type KeyUsageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyUsageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyUsageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyUsageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyUsageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyUsageValidationError) ErrorName() string { return "KeyUsageValidationError" }

// Error satisfies the builtin error interface
func (e KeyUsageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyUsage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyUsageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyUsageValidationError{}

// Validate checks the field values on Name with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Name) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Name with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NameMultiError, or nil if none found.
func (m *Name) ValidateAll() error {
	return m.validate(true)
}

func (m *Name) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SerialNumber

	// no validation rules for CommonName

	if len(errors) > 0 {
		return NameMultiError(errors)
	}

	return nil
}

// NameMultiError is an error wrapping multiple validation errors returned by
// Name.ValidateAll() if the designated constraints aren't met.
type NameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NameMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NameMultiError) AllErrors() []error { return m }

// NameValidationError is the validation error returned by Name.Validate if the
// designated constraints aren't met.
type NameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NameValidationError) ErrorName() string { return "NameValidationError" }

// Error satisfies the builtin error interface
func (e NameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NameValidationError{}

// Validate checks the field values on CertificateInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CertificateInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CertificateInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CertificateInfoMultiError, or nil if none found.
func (m *CertificateInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CertificateInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	// no validation rules for Serial

	if all {
		switch v := interface{}(m.GetIssuer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CertificateInfoValidationError{
					field:  "Issuer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CertificateInfoValidationError{
					field:  "Issuer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssuer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CertificateInfoValidationError{
				field:  "Issuer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CertificateInfoValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CertificateInfoValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CertificateInfoValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNotBefore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CertificateInfoValidationError{
					field:  "NotBefore",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CertificateInfoValidationError{
					field:  "NotBefore",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNotBefore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CertificateInfoValidationError{
				field:  "NotBefore",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNotAfter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CertificateInfoValidationError{
					field:  "NotAfter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CertificateInfoValidationError{
					field:  "NotAfter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNotAfter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CertificateInfoValidationError{
				field:  "NotAfter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKeyUsage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CertificateInfoValidationError{
					field:  "KeyUsage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CertificateInfoValidationError{
					field:  "KeyUsage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKeyUsage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CertificateInfoValidationError{
				field:  "KeyUsage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PermittedDnsDomainsCritical

	if len(errors) > 0 {
		return CertificateInfoMultiError(errors)
	}

	return nil
}

// CertificateInfoMultiError is an error wrapping multiple validation errors
// returned by CertificateInfo.ValidateAll() if the designated constraints
// aren't met.
type CertificateInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CertificateInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CertificateInfoMultiError) AllErrors() []error { return m }

// CertificateInfoValidationError is the validation error returned by
// CertificateInfo.Validate if the designated constraints aren't met.
type CertificateInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CertificateInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CertificateInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CertificateInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CertificateInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CertificateInfoValidationError) ErrorName() string { return "CertificateInfoValidationError" }

// Error satisfies the builtin error interface
func (e CertificateInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCertificateInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CertificateInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CertificateInfoValidationError{}

// Validate checks the field values on CreateKeyPairRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateKeyPairRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateKeyPairRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateKeyPairRequestMultiError, or nil if none found.
func (m *CreateKeyPairRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateKeyPairRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetKeyPair()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateKeyPairRequestValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateKeyPairRequestValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKeyPair()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateKeyPairRequestValidationError{
				field:  "KeyPair",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateKeyPairRequestMultiError(errors)
	}

	return nil
}

// CreateKeyPairRequestMultiError is an error wrapping multiple validation
// errors returned by CreateKeyPairRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateKeyPairRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateKeyPairRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateKeyPairRequestMultiError) AllErrors() []error { return m }

// CreateKeyPairRequestValidationError is the validation error returned by
// CreateKeyPairRequest.Validate if the designated constraints aren't met.
type CreateKeyPairRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateKeyPairRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateKeyPairRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateKeyPairRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateKeyPairRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateKeyPairRequestValidationError) ErrorName() string {
	return "CreateKeyPairRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateKeyPairRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateKeyPairRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateKeyPairRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateKeyPairRequestValidationError{}

// Validate checks the field values on CreateKeyPairResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateKeyPairResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateKeyPairResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateKeyPairResponseMultiError, or nil if none found.
func (m *CreateKeyPairResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateKeyPairResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetKeyPair()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateKeyPairResponseValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateKeyPairResponseValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKeyPair()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateKeyPairResponseValidationError{
				field:  "KeyPair",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateKeyPairResponseMultiError(errors)
	}

	return nil
}

// CreateKeyPairResponseMultiError is an error wrapping multiple validation
// errors returned by CreateKeyPairResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateKeyPairResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateKeyPairResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateKeyPairResponseMultiError) AllErrors() []error { return m }

// CreateKeyPairResponseValidationError is the validation error returned by
// CreateKeyPairResponse.Validate if the designated constraints aren't met.
type CreateKeyPairResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateKeyPairResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateKeyPairResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateKeyPairResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateKeyPairResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateKeyPairResponseValidationError) ErrorName() string {
	return "CreateKeyPairResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateKeyPairResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateKeyPairResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateKeyPairResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateKeyPairResponseValidationError{}

// Validate checks the field values on CreatePolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePolicyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePolicyRequestMultiError, or nil if none found.
func (m *CreatePolicyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePolicyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePolicyRequestValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePolicyRequestValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePolicyRequestValidationError{
				field:  "Policy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePolicyRequestMultiError(errors)
	}

	return nil
}

// CreatePolicyRequestMultiError is an error wrapping multiple validation
// errors returned by CreatePolicyRequest.ValidateAll() if the designated
// constraints aren't met.
type CreatePolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePolicyRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePolicyRequestMultiError) AllErrors() []error { return m }

// CreatePolicyRequestValidationError is the validation error returned by
// CreatePolicyRequest.Validate if the designated constraints aren't met.
type CreatePolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePolicyRequestValidationError) ErrorName() string {
	return "CreatePolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePolicyRequestValidationError{}

// Validate checks the field values on CreatePolicyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePolicyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePolicyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePolicyResponseMultiError, or nil if none found.
func (m *CreatePolicyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePolicyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePolicyResponseValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePolicyResponseValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePolicyResponseValidationError{
				field:  "Policy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePolicyResponseMultiError(errors)
	}

	return nil
}

// CreatePolicyResponseMultiError is an error wrapping multiple validation
// errors returned by CreatePolicyResponse.ValidateAll() if the designated
// constraints aren't met.
type CreatePolicyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePolicyResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePolicyResponseMultiError) AllErrors() []error { return m }

// CreatePolicyResponseValidationError is the validation error returned by
// CreatePolicyResponse.Validate if the designated constraints aren't met.
type CreatePolicyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePolicyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePolicyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePolicyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePolicyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePolicyResponseValidationError) ErrorName() string {
	return "CreatePolicyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePolicyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePolicyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePolicyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePolicyResponseValidationError{}

// Validate checks the field values on CreateRouteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRouteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRouteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRouteRequestMultiError, or nil if none found.
func (m *CreateRouteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRouteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRoute()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRouteRequestValidationError{
					field:  "Route",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRouteRequestValidationError{
					field:  "Route",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRoute()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRouteRequestValidationError{
				field:  "Route",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRouteRequestMultiError(errors)
	}

	return nil
}

// CreateRouteRequestMultiError is an error wrapping multiple validation errors
// returned by CreateRouteRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateRouteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRouteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRouteRequestMultiError) AllErrors() []error { return m }

// CreateRouteRequestValidationError is the validation error returned by
// CreateRouteRequest.Validate if the designated constraints aren't met.
type CreateRouteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRouteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRouteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRouteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRouteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRouteRequestValidationError) ErrorName() string {
	return "CreateRouteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRouteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRouteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRouteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRouteRequestValidationError{}

// Validate checks the field values on CreateRouteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRouteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRouteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRouteResponseMultiError, or nil if none found.
func (m *CreateRouteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRouteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRoute()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRouteResponseValidationError{
					field:  "Route",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRouteResponseValidationError{
					field:  "Route",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRoute()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRouteResponseValidationError{
				field:  "Route",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRouteResponseMultiError(errors)
	}

	return nil
}

// CreateRouteResponseMultiError is an error wrapping multiple validation
// errors returned by CreateRouteResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateRouteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRouteResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRouteResponseMultiError) AllErrors() []error { return m }

// CreateRouteResponseValidationError is the validation error returned by
// CreateRouteResponse.Validate if the designated constraints aren't met.
type CreateRouteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRouteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRouteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRouteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRouteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRouteResponseValidationError) ErrorName() string {
	return "CreateRouteResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRouteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRouteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRouteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRouteResponseValidationError{}

// Validate checks the field values on DeleteKeyPairRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteKeyPairRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteKeyPairRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteKeyPairRequestMultiError, or nil if none found.
func (m *DeleteKeyPairRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteKeyPairRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteKeyPairRequestMultiError(errors)
	}

	return nil
}

// DeleteKeyPairRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteKeyPairRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteKeyPairRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteKeyPairRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteKeyPairRequestMultiError) AllErrors() []error { return m }

// DeleteKeyPairRequestValidationError is the validation error returned by
// DeleteKeyPairRequest.Validate if the designated constraints aren't met.
type DeleteKeyPairRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteKeyPairRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteKeyPairRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteKeyPairRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteKeyPairRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteKeyPairRequestValidationError) ErrorName() string {
	return "DeleteKeyPairRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteKeyPairRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteKeyPairRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteKeyPairRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteKeyPairRequestValidationError{}

// Validate checks the field values on DeleteKeyPairResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteKeyPairResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteKeyPairResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteKeyPairResponseMultiError, or nil if none found.
func (m *DeleteKeyPairResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteKeyPairResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteKeyPairResponseMultiError(errors)
	}

	return nil
}

// DeleteKeyPairResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteKeyPairResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteKeyPairResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteKeyPairResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteKeyPairResponseMultiError) AllErrors() []error { return m }

// DeleteKeyPairResponseValidationError is the validation error returned by
// DeleteKeyPairResponse.Validate if the designated constraints aren't met.
type DeleteKeyPairResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteKeyPairResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteKeyPairResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteKeyPairResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteKeyPairResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteKeyPairResponseValidationError) ErrorName() string {
	return "DeleteKeyPairResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteKeyPairResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteKeyPairResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteKeyPairResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteKeyPairResponseValidationError{}

// Validate checks the field values on DeletePolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeletePolicyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePolicyRequestMultiError, or nil if none found.
func (m *DeletePolicyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePolicyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeletePolicyRequestMultiError(errors)
	}

	return nil
}

// DeletePolicyRequestMultiError is an error wrapping multiple validation
// errors returned by DeletePolicyRequest.ValidateAll() if the designated
// constraints aren't met.
type DeletePolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePolicyRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePolicyRequestMultiError) AllErrors() []error { return m }

// DeletePolicyRequestValidationError is the validation error returned by
// DeletePolicyRequest.Validate if the designated constraints aren't met.
type DeletePolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePolicyRequestValidationError) ErrorName() string {
	return "DeletePolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePolicyRequestValidationError{}

// Validate checks the field values on DeletePolicyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeletePolicyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePolicyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePolicyResponseMultiError, or nil if none found.
func (m *DeletePolicyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePolicyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeletePolicyResponseMultiError(errors)
	}

	return nil
}

// DeletePolicyResponseMultiError is an error wrapping multiple validation
// errors returned by DeletePolicyResponse.ValidateAll() if the designated
// constraints aren't met.
type DeletePolicyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePolicyResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePolicyResponseMultiError) AllErrors() []error { return m }

// DeletePolicyResponseValidationError is the validation error returned by
// DeletePolicyResponse.Validate if the designated constraints aren't met.
type DeletePolicyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePolicyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePolicyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePolicyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePolicyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePolicyResponseValidationError) ErrorName() string {
	return "DeletePolicyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePolicyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePolicyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePolicyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePolicyResponseValidationError{}

// Validate checks the field values on DeleteRouteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRouteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRouteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRouteRequestMultiError, or nil if none found.
func (m *DeleteRouteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRouteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteRouteRequestMultiError(errors)
	}

	return nil
}

// DeleteRouteRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteRouteRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteRouteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRouteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRouteRequestMultiError) AllErrors() []error { return m }

// DeleteRouteRequestValidationError is the validation error returned by
// DeleteRouteRequest.Validate if the designated constraints aren't met.
type DeleteRouteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRouteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRouteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRouteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRouteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRouteRequestValidationError) ErrorName() string {
	return "DeleteRouteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRouteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRouteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRouteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRouteRequestValidationError{}

// Validate checks the field values on DeleteRouteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRouteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRouteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRouteResponseMultiError, or nil if none found.
func (m *DeleteRouteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRouteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteRouteResponseMultiError(errors)
	}

	return nil
}

// DeleteRouteResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteRouteResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteRouteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRouteResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRouteResponseMultiError) AllErrors() []error { return m }

// DeleteRouteResponseValidationError is the validation error returned by
// DeleteRouteResponse.Validate if the designated constraints aren't met.
type DeleteRouteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRouteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRouteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRouteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRouteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRouteResponseValidationError) ErrorName() string {
	return "DeleteRouteResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRouteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRouteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRouteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRouteResponseValidationError{}

// Validate checks the field values on GetKeyPairRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetKeyPairRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetKeyPairRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetKeyPairRequestMultiError, or nil if none found.
func (m *GetKeyPairRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetKeyPairRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetKeyPairRequestMultiError(errors)
	}

	return nil
}

// GetKeyPairRequestMultiError is an error wrapping multiple validation errors
// returned by GetKeyPairRequest.ValidateAll() if the designated constraints
// aren't met.
type GetKeyPairRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetKeyPairRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetKeyPairRequestMultiError) AllErrors() []error { return m }

// GetKeyPairRequestValidationError is the validation error returned by
// GetKeyPairRequest.Validate if the designated constraints aren't met.
type GetKeyPairRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetKeyPairRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetKeyPairRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetKeyPairRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetKeyPairRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetKeyPairRequestValidationError) ErrorName() string {
	return "GetKeyPairRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetKeyPairRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetKeyPairRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetKeyPairRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetKeyPairRequestValidationError{}

// Validate checks the field values on GetKeyPairResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetKeyPairResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetKeyPairResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetKeyPairResponseMultiError, or nil if none found.
func (m *GetKeyPairResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetKeyPairResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetKeyPair()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetKeyPairResponseValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetKeyPairResponseValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKeyPair()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetKeyPairResponseValidationError{
				field:  "KeyPair",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetKeyPairResponseMultiError(errors)
	}

	return nil
}

// GetKeyPairResponseMultiError is an error wrapping multiple validation errors
// returned by GetKeyPairResponse.ValidateAll() if the designated constraints
// aren't met.
type GetKeyPairResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetKeyPairResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetKeyPairResponseMultiError) AllErrors() []error { return m }

// GetKeyPairResponseValidationError is the validation error returned by
// GetKeyPairResponse.Validate if the designated constraints aren't met.
type GetKeyPairResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetKeyPairResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetKeyPairResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetKeyPairResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetKeyPairResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetKeyPairResponseValidationError) ErrorName() string {
	return "GetKeyPairResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetKeyPairResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetKeyPairResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetKeyPairResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetKeyPairResponseValidationError{}

// Validate checks the field values on GetPolicyRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetPolicyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPolicyRequestMultiError, or nil if none found.
func (m *GetPolicyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPolicyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetPolicyRequestMultiError(errors)
	}

	return nil
}

// GetPolicyRequestMultiError is an error wrapping multiple validation errors
// returned by GetPolicyRequest.ValidateAll() if the designated constraints
// aren't met.
type GetPolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPolicyRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPolicyRequestMultiError) AllErrors() []error { return m }

// GetPolicyRequestValidationError is the validation error returned by
// GetPolicyRequest.Validate if the designated constraints aren't met.
type GetPolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPolicyRequestValidationError) ErrorName() string { return "GetPolicyRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetPolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPolicyRequestValidationError{}

// Validate checks the field values on GetPolicyResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetPolicyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPolicyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPolicyResponseMultiError, or nil if none found.
func (m *GetPolicyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPolicyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPolicyResponseValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPolicyResponseValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPolicyResponseValidationError{
				field:  "Policy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetPolicyResponseMultiError(errors)
	}

	return nil
}

// GetPolicyResponseMultiError is an error wrapping multiple validation errors
// returned by GetPolicyResponse.ValidateAll() if the designated constraints
// aren't met.
type GetPolicyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPolicyResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPolicyResponseMultiError) AllErrors() []error { return m }

// GetPolicyResponseValidationError is the validation error returned by
// GetPolicyResponse.Validate if the designated constraints aren't met.
type GetPolicyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPolicyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPolicyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPolicyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPolicyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPolicyResponseValidationError) ErrorName() string {
	return "GetPolicyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetPolicyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPolicyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPolicyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPolicyResponseValidationError{}

// Validate checks the field values on GetRouteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetRouteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRouteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRouteRequestMultiError, or nil if none found.
func (m *GetRouteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRouteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetRouteRequestMultiError(errors)
	}

	return nil
}

// GetRouteRequestMultiError is an error wrapping multiple validation errors
// returned by GetRouteRequest.ValidateAll() if the designated constraints
// aren't met.
type GetRouteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRouteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRouteRequestMultiError) AllErrors() []error { return m }

// GetRouteRequestValidationError is the validation error returned by
// GetRouteRequest.Validate if the designated constraints aren't met.
type GetRouteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRouteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRouteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRouteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRouteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRouteRequestValidationError) ErrorName() string { return "GetRouteRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetRouteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRouteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRouteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRouteRequestValidationError{}

// Validate checks the field values on GetRouteResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetRouteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRouteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRouteResponseMultiError, or nil if none found.
func (m *GetRouteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRouteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRoute()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRouteResponseValidationError{
					field:  "Route",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRouteResponseValidationError{
					field:  "Route",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRoute()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRouteResponseValidationError{
				field:  "Route",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetRouteResponseMultiError(errors)
	}

	return nil
}

// GetRouteResponseMultiError is an error wrapping multiple validation errors
// returned by GetRouteResponse.ValidateAll() if the designated constraints
// aren't met.
type GetRouteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRouteResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRouteResponseMultiError) AllErrors() []error { return m }

// GetRouteResponseValidationError is the validation error returned by
// GetRouteResponse.Validate if the designated constraints aren't met.
type GetRouteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRouteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRouteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRouteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRouteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRouteResponseValidationError) ErrorName() string { return "GetRouteResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetRouteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRouteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRouteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRouteResponseValidationError{}

// Validate checks the field values on GetSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSettingsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSettingsRequestMultiError, or nil if none found.
func (m *GetSettingsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSettingsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetSettingsRequestMultiError(errors)
	}

	return nil
}

// GetSettingsRequestMultiError is an error wrapping multiple validation errors
// returned by GetSettingsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetSettingsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSettingsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSettingsRequestMultiError) AllErrors() []error { return m }

// GetSettingsRequestValidationError is the validation error returned by
// GetSettingsRequest.Validate if the designated constraints aren't met.
type GetSettingsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSettingsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSettingsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSettingsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSettingsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSettingsRequestValidationError) ErrorName() string {
	return "GetSettingsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSettingsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSettingsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSettingsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSettingsRequestValidationError{}

// Validate checks the field values on GetSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSettingsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSettingsResponseMultiError, or nil if none found.
func (m *GetSettingsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSettingsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSettingsResponseValidationError{
				field:  "Settings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSettingsResponseMultiError(errors)
	}

	return nil
}

// GetSettingsResponseMultiError is an error wrapping multiple validation
// errors returned by GetSettingsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetSettingsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSettingsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSettingsResponseMultiError) AllErrors() []error { return m }

// GetSettingsResponseValidationError is the validation error returned by
// GetSettingsResponse.Validate if the designated constraints aren't met.
type GetSettingsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSettingsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSettingsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSettingsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSettingsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSettingsResponseValidationError) ErrorName() string {
	return "GetSettingsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSettingsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSettingsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSettingsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSettingsResponseValidationError{}

// Validate checks the field values on ListKeyPairsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListKeyPairsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListKeyPairsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListKeyPairsRequestMultiError, or nil if none found.
func (m *ListKeyPairsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListKeyPairsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Offset != nil {
		// no validation rules for Offset
	}

	if m.Limit != nil {
		// no validation rules for Limit
	}

	if m.Filter != nil {
		// no validation rules for Filter
	}

	if m.OrderBy != nil {
		// no validation rules for OrderBy
	}

	if len(errors) > 0 {
		return ListKeyPairsRequestMultiError(errors)
	}

	return nil
}

// ListKeyPairsRequestMultiError is an error wrapping multiple validation
// errors returned by ListKeyPairsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListKeyPairsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListKeyPairsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListKeyPairsRequestMultiError) AllErrors() []error { return m }

// ListKeyPairsRequestValidationError is the validation error returned by
// ListKeyPairsRequest.Validate if the designated constraints aren't met.
type ListKeyPairsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListKeyPairsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListKeyPairsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListKeyPairsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListKeyPairsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListKeyPairsRequestValidationError) ErrorName() string {
	return "ListKeyPairsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListKeyPairsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListKeyPairsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListKeyPairsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListKeyPairsRequestValidationError{}

// Validate checks the field values on ListKeyPairsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListKeyPairsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListKeyPairsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListKeyPairsResponseMultiError, or nil if none found.
func (m *ListKeyPairsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListKeyPairsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetKeyPairs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListKeyPairsResponseValidationError{
						field:  fmt.Sprintf("KeyPairs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListKeyPairsResponseValidationError{
						field:  fmt.Sprintf("KeyPairs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListKeyPairsResponseValidationError{
					field:  fmt.Sprintf("KeyPairs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalCount

	if len(errors) > 0 {
		return ListKeyPairsResponseMultiError(errors)
	}

	return nil
}

// ListKeyPairsResponseMultiError is an error wrapping multiple validation
// errors returned by ListKeyPairsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListKeyPairsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListKeyPairsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListKeyPairsResponseMultiError) AllErrors() []error { return m }

// ListKeyPairsResponseValidationError is the validation error returned by
// ListKeyPairsResponse.Validate if the designated constraints aren't met.
type ListKeyPairsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListKeyPairsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListKeyPairsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListKeyPairsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListKeyPairsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListKeyPairsResponseValidationError) ErrorName() string {
	return "ListKeyPairsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListKeyPairsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListKeyPairsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListKeyPairsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListKeyPairsResponseValidationError{}

// Validate checks the field values on ListPoliciesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPoliciesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPoliciesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPoliciesRequestMultiError, or nil if none found.
func (m *ListPoliciesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPoliciesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Offset != nil {
		// no validation rules for Offset
	}

	if m.Limit != nil {
		// no validation rules for Limit
	}

	if m.Filter != nil {
		// no validation rules for Filter
	}

	if m.OrderBy != nil {
		// no validation rules for OrderBy
	}

	if len(errors) > 0 {
		return ListPoliciesRequestMultiError(errors)
	}

	return nil
}

// ListPoliciesRequestMultiError is an error wrapping multiple validation
// errors returned by ListPoliciesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListPoliciesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPoliciesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPoliciesRequestMultiError) AllErrors() []error { return m }

// ListPoliciesRequestValidationError is the validation error returned by
// ListPoliciesRequest.Validate if the designated constraints aren't met.
type ListPoliciesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPoliciesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPoliciesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPoliciesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPoliciesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPoliciesRequestValidationError) ErrorName() string {
	return "ListPoliciesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListPoliciesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPoliciesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPoliciesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPoliciesRequestValidationError{}

// Validate checks the field values on ListPoliciesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPoliciesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPoliciesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPoliciesResponseMultiError, or nil if none found.
func (m *ListPoliciesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPoliciesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPolicies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPoliciesResponseValidationError{
						field:  fmt.Sprintf("Policies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPoliciesResponseValidationError{
						field:  fmt.Sprintf("Policies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPoliciesResponseValidationError{
					field:  fmt.Sprintf("Policies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalCount

	if len(errors) > 0 {
		return ListPoliciesResponseMultiError(errors)
	}

	return nil
}

// ListPoliciesResponseMultiError is an error wrapping multiple validation
// errors returned by ListPoliciesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListPoliciesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPoliciesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPoliciesResponseMultiError) AllErrors() []error { return m }

// ListPoliciesResponseValidationError is the validation error returned by
// ListPoliciesResponse.Validate if the designated constraints aren't met.
type ListPoliciesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPoliciesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPoliciesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPoliciesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPoliciesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPoliciesResponseValidationError) ErrorName() string {
	return "ListPoliciesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListPoliciesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPoliciesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPoliciesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPoliciesResponseValidationError{}

// Validate checks the field values on ListRoutesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRoutesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoutesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRoutesRequestMultiError, or nil if none found.
func (m *ListRoutesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoutesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Offset != nil {
		// no validation rules for Offset
	}

	if m.Limit != nil {
		// no validation rules for Limit
	}

	if m.Filter != nil {
		// no validation rules for Filter
	}

	if m.OrderBy != nil {
		// no validation rules for OrderBy
	}

	if len(errors) > 0 {
		return ListRoutesRequestMultiError(errors)
	}

	return nil
}

// ListRoutesRequestMultiError is an error wrapping multiple validation errors
// returned by ListRoutesRequest.ValidateAll() if the designated constraints
// aren't met.
type ListRoutesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoutesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoutesRequestMultiError) AllErrors() []error { return m }

// ListRoutesRequestValidationError is the validation error returned by
// ListRoutesRequest.Validate if the designated constraints aren't met.
type ListRoutesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoutesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoutesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoutesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoutesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoutesRequestValidationError) ErrorName() string {
	return "ListRoutesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListRoutesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoutesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoutesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoutesRequestValidationError{}

// Validate checks the field values on ListRoutesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRoutesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoutesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRoutesResponseMultiError, or nil if none found.
func (m *ListRoutesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoutesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRoutes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRoutesResponseValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRoutesResponseValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRoutesResponseValidationError{
					field:  fmt.Sprintf("Routes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalCount

	if len(errors) > 0 {
		return ListRoutesResponseMultiError(errors)
	}

	return nil
}

// ListRoutesResponseMultiError is an error wrapping multiple validation errors
// returned by ListRoutesResponse.ValidateAll() if the designated constraints
// aren't met.
type ListRoutesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoutesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoutesResponseMultiError) AllErrors() []error { return m }

// ListRoutesResponseValidationError is the validation error returned by
// ListRoutesResponse.Validate if the designated constraints aren't met.
type ListRoutesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoutesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoutesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoutesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoutesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoutesResponseValidationError) ErrorName() string {
	return "ListRoutesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListRoutesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoutesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoutesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoutesResponseValidationError{}

// Validate checks the field values on ListSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSettingsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSettingsRequestMultiError, or nil if none found.
func (m *ListSettingsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSettingsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Offset != nil {
		// no validation rules for Offset
	}

	if m.Limit != nil {
		// no validation rules for Limit
	}

	if m.Filter != nil {

		if all {
			switch v := interface{}(m.GetFilter()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSettingsRequestValidationError{
						field:  "Filter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSettingsRequestValidationError{
						field:  "Filter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSettingsRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.OrderBy != nil {
		// no validation rules for OrderBy
	}

	if len(errors) > 0 {
		return ListSettingsRequestMultiError(errors)
	}

	return nil
}

// ListSettingsRequestMultiError is an error wrapping multiple validation
// errors returned by ListSettingsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListSettingsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSettingsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSettingsRequestMultiError) AllErrors() []error { return m }

// ListSettingsRequestValidationError is the validation error returned by
// ListSettingsRequest.Validate if the designated constraints aren't met.
type ListSettingsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSettingsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSettingsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSettingsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSettingsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSettingsRequestValidationError) ErrorName() string {
	return "ListSettingsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListSettingsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSettingsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSettingsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSettingsRequestValidationError{}

// Validate checks the field values on ListSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSettingsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSettingsResponseMultiError, or nil if none found.
func (m *ListSettingsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSettingsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSettings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSettingsResponseValidationError{
						field:  fmt.Sprintf("Settings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSettingsResponseValidationError{
						field:  fmt.Sprintf("Settings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSettingsResponseValidationError{
					field:  fmt.Sprintf("Settings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalCount

	if len(errors) > 0 {
		return ListSettingsResponseMultiError(errors)
	}

	return nil
}

// ListSettingsResponseMultiError is an error wrapping multiple validation
// errors returned by ListSettingsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListSettingsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSettingsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSettingsResponseMultiError) AllErrors() []error { return m }

// ListSettingsResponseValidationError is the validation error returned by
// ListSettingsResponse.Validate if the designated constraints aren't met.
type ListSettingsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSettingsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSettingsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSettingsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSettingsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSettingsResponseValidationError) ErrorName() string {
	return "ListSettingsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListSettingsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSettingsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSettingsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSettingsResponseValidationError{}

// Validate checks the field values on UpdateKeyPairRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateKeyPairRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateKeyPairRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateKeyPairRequestMultiError, or nil if none found.
func (m *UpdateKeyPairRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateKeyPairRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetKeyPair()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateKeyPairRequestValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateKeyPairRequestValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKeyPair()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateKeyPairRequestValidationError{
				field:  "KeyPair",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateKeyPairRequestMultiError(errors)
	}

	return nil
}

// UpdateKeyPairRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateKeyPairRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateKeyPairRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateKeyPairRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateKeyPairRequestMultiError) AllErrors() []error { return m }

// UpdateKeyPairRequestValidationError is the validation error returned by
// UpdateKeyPairRequest.Validate if the designated constraints aren't met.
type UpdateKeyPairRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateKeyPairRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateKeyPairRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateKeyPairRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateKeyPairRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateKeyPairRequestValidationError) ErrorName() string {
	return "UpdateKeyPairRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateKeyPairRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateKeyPairRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateKeyPairRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateKeyPairRequestValidationError{}

// Validate checks the field values on UpdateKeyPairResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateKeyPairResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateKeyPairResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateKeyPairResponseMultiError, or nil if none found.
func (m *UpdateKeyPairResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateKeyPairResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetKeyPair()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateKeyPairResponseValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateKeyPairResponseValidationError{
					field:  "KeyPair",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKeyPair()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateKeyPairResponseValidationError{
				field:  "KeyPair",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateKeyPairResponseMultiError(errors)
	}

	return nil
}

// UpdateKeyPairResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateKeyPairResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateKeyPairResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateKeyPairResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateKeyPairResponseMultiError) AllErrors() []error { return m }

// UpdateKeyPairResponseValidationError is the validation error returned by
// UpdateKeyPairResponse.Validate if the designated constraints aren't met.
type UpdateKeyPairResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateKeyPairResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateKeyPairResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateKeyPairResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateKeyPairResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateKeyPairResponseValidationError) ErrorName() string {
	return "UpdateKeyPairResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateKeyPairResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateKeyPairResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateKeyPairResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateKeyPairResponseValidationError{}

// Validate checks the field values on UpdatePolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePolicyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePolicyRequestMultiError, or nil if none found.
func (m *UpdatePolicyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePolicyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePolicyRequestValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePolicyRequestValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePolicyRequestValidationError{
				field:  "Policy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePolicyRequestMultiError(errors)
	}

	return nil
}

// UpdatePolicyRequestMultiError is an error wrapping multiple validation
// errors returned by UpdatePolicyRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdatePolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePolicyRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePolicyRequestMultiError) AllErrors() []error { return m }

// UpdatePolicyRequestValidationError is the validation error returned by
// UpdatePolicyRequest.Validate if the designated constraints aren't met.
type UpdatePolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePolicyRequestValidationError) ErrorName() string {
	return "UpdatePolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePolicyRequestValidationError{}

// Validate checks the field values on UpdatePolicyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePolicyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePolicyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePolicyResponseMultiError, or nil if none found.
func (m *UpdatePolicyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePolicyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePolicyResponseValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePolicyResponseValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePolicyResponseValidationError{
				field:  "Policy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePolicyResponseMultiError(errors)
	}

	return nil
}

// UpdatePolicyResponseMultiError is an error wrapping multiple validation
// errors returned by UpdatePolicyResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdatePolicyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePolicyResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePolicyResponseMultiError) AllErrors() []error { return m }

// UpdatePolicyResponseValidationError is the validation error returned by
// UpdatePolicyResponse.Validate if the designated constraints aren't met.
type UpdatePolicyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePolicyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePolicyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePolicyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePolicyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePolicyResponseValidationError) ErrorName() string {
	return "UpdatePolicyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePolicyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePolicyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePolicyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePolicyResponseValidationError{}

// Validate checks the field values on UpdateRouteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRouteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRouteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRouteRequestMultiError, or nil if none found.
func (m *UpdateRouteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRouteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRoute()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRouteRequestValidationError{
					field:  "Route",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRouteRequestValidationError{
					field:  "Route",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRoute()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRouteRequestValidationError{
				field:  "Route",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRouteRequestMultiError(errors)
	}

	return nil
}

// UpdateRouteRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateRouteRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateRouteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRouteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRouteRequestMultiError) AllErrors() []error { return m }

// UpdateRouteRequestValidationError is the validation error returned by
// UpdateRouteRequest.Validate if the designated constraints aren't met.
type UpdateRouteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRouteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRouteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRouteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRouteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRouteRequestValidationError) ErrorName() string {
	return "UpdateRouteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRouteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRouteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRouteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRouteRequestValidationError{}

// Validate checks the field values on UpdateRouteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRouteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRouteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRouteResponseMultiError, or nil if none found.
func (m *UpdateRouteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRouteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRoute()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRouteResponseValidationError{
					field:  "Route",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRouteResponseValidationError{
					field:  "Route",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRoute()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRouteResponseValidationError{
				field:  "Route",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRouteResponseMultiError(errors)
	}

	return nil
}

// UpdateRouteResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateRouteResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateRouteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRouteResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRouteResponseMultiError) AllErrors() []error { return m }

// UpdateRouteResponseValidationError is the validation error returned by
// UpdateRouteResponse.Validate if the designated constraints aren't met.
type UpdateRouteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRouteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRouteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRouteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRouteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRouteResponseValidationError) ErrorName() string {
	return "UpdateRouteResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRouteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRouteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRouteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRouteResponseValidationError{}

// Validate checks the field values on UpdateSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSettingsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSettingsRequestMultiError, or nil if none found.
func (m *UpdateSettingsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSettingsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSettingsRequestValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSettingsRequestValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSettingsRequestValidationError{
				field:  "Settings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateSettingsRequestMultiError(errors)
	}

	return nil
}

// UpdateSettingsRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateSettingsRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateSettingsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSettingsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSettingsRequestMultiError) AllErrors() []error { return m }

// UpdateSettingsRequestValidationError is the validation error returned by
// UpdateSettingsRequest.Validate if the designated constraints aren't met.
type UpdateSettingsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSettingsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSettingsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSettingsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSettingsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSettingsRequestValidationError) ErrorName() string {
	return "UpdateSettingsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSettingsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSettingsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSettingsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSettingsRequestValidationError{}

// Validate checks the field values on UpdateSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSettingsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSettingsResponseMultiError, or nil if none found.
func (m *UpdateSettingsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSettingsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSettingsResponseValidationError{
				field:  "Settings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateSettingsResponseMultiError(errors)
	}

	return nil
}

// UpdateSettingsResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateSettingsResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateSettingsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSettingsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSettingsResponseMultiError) AllErrors() []error { return m }

// UpdateSettingsResponseValidationError is the validation error returned by
// UpdateSettingsResponse.Validate if the designated constraints aren't met.
type UpdateSettingsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSettingsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSettingsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSettingsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSettingsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSettingsResponseValidationError) ErrorName() string {
	return "UpdateSettingsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSettingsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSettingsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSettingsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSettingsResponseValidationError{}

// Validate checks the field values on HealthCheck with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HealthCheck) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthCheck with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HealthCheckMultiError, or
// nil if none found.
func (m *HealthCheck) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthCheck) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "Timeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "Interval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInitialJitter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "InitialJitter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "InitialJitter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialJitter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "InitialJitter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIntervalJitter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "IntervalJitter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "IntervalJitter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIntervalJitter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "IntervalJitter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IntervalJitterPercent

	if all {
		switch v := interface{}(m.GetUnhealthyThreshold()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "UnhealthyThreshold",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "UnhealthyThreshold",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUnhealthyThreshold()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "UnhealthyThreshold",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHealthyThreshold()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "HealthyThreshold",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "HealthyThreshold",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHealthyThreshold()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "HealthyThreshold",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAltPort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "AltPort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "AltPort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAltPort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "AltPort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReuseConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "ReuseConnection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "ReuseConnection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReuseConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "ReuseConnection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNoTrafficInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "NoTrafficInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "NoTrafficInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNoTrafficInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "NoTrafficInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNoTrafficHealthyInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "NoTrafficHealthyInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "NoTrafficHealthyInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNoTrafficHealthyInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "NoTrafficHealthyInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUnhealthyInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "UnhealthyInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "UnhealthyInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUnhealthyInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "UnhealthyInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUnhealthyEdgeInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "UnhealthyEdgeInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "UnhealthyEdgeInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUnhealthyEdgeInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "UnhealthyEdgeInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHealthyEdgeInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "HealthyEdgeInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "HealthyEdgeInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHealthyEdgeInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "HealthyEdgeInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AlwaysLogHealthCheckFailures

	// no validation rules for AlwaysLogHealthCheckSuccess

	if all {
		switch v := interface{}(m.GetTransportSocketMatchCriteria()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "TransportSocketMatchCriteria",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheckValidationError{
					field:  "TransportSocketMatchCriteria",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransportSocketMatchCriteria()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheckValidationError{
				field:  "TransportSocketMatchCriteria",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.HealthChecker.(type) {
	case *HealthCheck_HttpHealthCheck_:
		if v == nil {
			err := HealthCheckValidationError{
				field:  "HealthChecker",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHttpHealthCheck()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HealthCheckValidationError{
						field:  "HttpHealthCheck",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HealthCheckValidationError{
						field:  "HttpHealthCheck",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHttpHealthCheck()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HealthCheckValidationError{
					field:  "HttpHealthCheck",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *HealthCheck_TcpHealthCheck_:
		if v == nil {
			err := HealthCheckValidationError{
				field:  "HealthChecker",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTcpHealthCheck()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HealthCheckValidationError{
						field:  "TcpHealthCheck",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HealthCheckValidationError{
						field:  "TcpHealthCheck",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTcpHealthCheck()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HealthCheckValidationError{
					field:  "TcpHealthCheck",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *HealthCheck_GrpcHealthCheck_:
		if v == nil {
			err := HealthCheckValidationError{
				field:  "HealthChecker",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGrpcHealthCheck()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HealthCheckValidationError{
						field:  "GrpcHealthCheck",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HealthCheckValidationError{
						field:  "GrpcHealthCheck",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGrpcHealthCheck()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HealthCheckValidationError{
					field:  "GrpcHealthCheck",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return HealthCheckMultiError(errors)
	}

	return nil
}

// HealthCheckMultiError is an error wrapping multiple validation errors
// returned by HealthCheck.ValidateAll() if the designated constraints aren't met.
type HealthCheckMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthCheckMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthCheckMultiError) AllErrors() []error { return m }

// HealthCheckValidationError is the validation error returned by
// HealthCheck.Validate if the designated constraints aren't met.
type HealthCheckValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthCheckValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthCheckValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthCheckValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthCheckValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthCheckValidationError) ErrorName() string { return "HealthCheckValidationError" }

// Error satisfies the builtin error interface
func (e HealthCheckValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthCheck.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthCheckValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthCheckValidationError{}

// Validate checks the field values on OutlierDetection with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OutlierDetection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OutlierDetection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OutlierDetectionMultiError, or nil if none found.
func (m *OutlierDetection) ValidateAll() error {
	return m.validate(true)
}

func (m *OutlierDetection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsecutive_5Xx()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "Consecutive_5Xx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "Consecutive_5Xx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsecutive_5Xx()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "Consecutive_5Xx",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "Interval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBaseEjectionTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "BaseEjectionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "BaseEjectionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseEjectionTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "BaseEjectionTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMaxEjectionPercent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "MaxEjectionPercent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "MaxEjectionPercent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxEjectionPercent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "MaxEjectionPercent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnforcingConsecutive_5Xx()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingConsecutive_5Xx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingConsecutive_5Xx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnforcingConsecutive_5Xx()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "EnforcingConsecutive_5Xx",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnforcingSuccessRate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingSuccessRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingSuccessRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnforcingSuccessRate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "EnforcingSuccessRate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSuccessRateMinimumHosts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "SuccessRateMinimumHosts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "SuccessRateMinimumHosts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSuccessRateMinimumHosts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "SuccessRateMinimumHosts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSuccessRateRequestVolume()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "SuccessRateRequestVolume",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "SuccessRateRequestVolume",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSuccessRateRequestVolume()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "SuccessRateRequestVolume",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSuccessRateStdevFactor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "SuccessRateStdevFactor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "SuccessRateStdevFactor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSuccessRateStdevFactor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "SuccessRateStdevFactor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConsecutiveGatewayFailure()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "ConsecutiveGatewayFailure",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "ConsecutiveGatewayFailure",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsecutiveGatewayFailure()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "ConsecutiveGatewayFailure",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnforcingConsecutiveGatewayFailure()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingConsecutiveGatewayFailure",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingConsecutiveGatewayFailure",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnforcingConsecutiveGatewayFailure()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "EnforcingConsecutiveGatewayFailure",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SplitExternalLocalOriginErrors

	if all {
		switch v := interface{}(m.GetConsecutiveLocalOriginFailure()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "ConsecutiveLocalOriginFailure",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "ConsecutiveLocalOriginFailure",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsecutiveLocalOriginFailure()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "ConsecutiveLocalOriginFailure",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnforcingConsecutiveLocalOriginFailure()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingConsecutiveLocalOriginFailure",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingConsecutiveLocalOriginFailure",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnforcingConsecutiveLocalOriginFailure()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "EnforcingConsecutiveLocalOriginFailure",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnforcingLocalOriginSuccessRate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingLocalOriginSuccessRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingLocalOriginSuccessRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnforcingLocalOriginSuccessRate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "EnforcingLocalOriginSuccessRate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFailurePercentageThreshold()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "FailurePercentageThreshold",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "FailurePercentageThreshold",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFailurePercentageThreshold()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "FailurePercentageThreshold",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnforcingFailurePercentage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingFailurePercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingFailurePercentage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnforcingFailurePercentage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "EnforcingFailurePercentage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnforcingFailurePercentageLocalOrigin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingFailurePercentageLocalOrigin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "EnforcingFailurePercentageLocalOrigin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnforcingFailurePercentageLocalOrigin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "EnforcingFailurePercentageLocalOrigin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFailurePercentageMinimumHosts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "FailurePercentageMinimumHosts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "FailurePercentageMinimumHosts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFailurePercentageMinimumHosts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "FailurePercentageMinimumHosts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFailurePercentageRequestVolume()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "FailurePercentageRequestVolume",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "FailurePercentageRequestVolume",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFailurePercentageRequestVolume()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "FailurePercentageRequestVolume",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMaxEjectionTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "MaxEjectionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "MaxEjectionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxEjectionTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "MaxEjectionTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMaxEjectionTimeJitter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "MaxEjectionTimeJitter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "MaxEjectionTimeJitter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxEjectionTimeJitter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "MaxEjectionTimeJitter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSuccessfulActiveHealthCheckUnejectHost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "SuccessfulActiveHealthCheckUnejectHost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "SuccessfulActiveHealthCheckUnejectHost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSuccessfulActiveHealthCheckUnejectHost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "SuccessfulActiveHealthCheckUnejectHost",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAlwaysEjectOneHost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "AlwaysEjectOneHost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutlierDetectionValidationError{
					field:  "AlwaysEjectOneHost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlwaysEjectOneHost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "AlwaysEjectOneHost",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OutlierDetectionMultiError(errors)
	}

	return nil
}

// OutlierDetectionMultiError is an error wrapping multiple validation errors
// returned by OutlierDetection.ValidateAll() if the designated constraints
// aren't met.
type OutlierDetectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OutlierDetectionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OutlierDetectionMultiError) AllErrors() []error { return m }

// OutlierDetectionValidationError is the validation error returned by
// OutlierDetection.Validate if the designated constraints aren't met.
type OutlierDetectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OutlierDetectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OutlierDetectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OutlierDetectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OutlierDetectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OutlierDetectionValidationError) ErrorName() string { return "OutlierDetectionValidationError" }

// Error satisfies the builtin error interface
func (e OutlierDetectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOutlierDetection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OutlierDetectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OutlierDetectionValidationError{}

// Validate checks the field values on VersionedConfig_Condition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VersionedConfig_Condition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VersionedConfig_Condition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VersionedConfig_ConditionMultiError, or nil if none found.
func (m *VersionedConfig_Condition) ValidateAll() error {
	return m.validate(true)
}

func (m *VersionedConfig_Condition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Feature != nil {
		// no validation rules for Feature
	}

	if m.AtLeast != nil {
		// no validation rules for AtLeast
	}

	if m.LessThan != nil {
		// no validation rules for LessThan
	}

	if len(errors) > 0 {
		return VersionedConfig_ConditionMultiError(errors)
	}

	return nil
}

// VersionedConfig_ConditionMultiError is an error wrapping multiple validation
// errors returned by VersionedConfig_Condition.ValidateAll() if the
// designated constraints aren't met.
type VersionedConfig_ConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VersionedConfig_ConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VersionedConfig_ConditionMultiError) AllErrors() []error { return m }

// VersionedConfig_ConditionValidationError is the validation error returned by
// VersionedConfig_Condition.Validate if the designated constraints aren't met.
type VersionedConfig_ConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VersionedConfig_ConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VersionedConfig_ConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VersionedConfig_ConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VersionedConfig_ConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VersionedConfig_ConditionValidationError) ErrorName() string {
	return "VersionedConfig_ConditionValidationError"
}

// Error satisfies the builtin error interface
func (e VersionedConfig_ConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVersionedConfig_Condition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VersionedConfig_ConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VersionedConfig_ConditionValidationError{}

// Validate checks the field values on Route_StringList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Route_StringList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Route_StringList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Route_StringListMultiError, or nil if none found.
func (m *Route_StringList) ValidateAll() error {
	return m.validate(true)
}

func (m *Route_StringList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Route_StringListMultiError(errors)
	}

	return nil
}

// Route_StringListMultiError is an error wrapping multiple validation errors
// returned by Route_StringList.ValidateAll() if the designated constraints
// aren't met.
type Route_StringListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Route_StringListMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Route_StringListMultiError) AllErrors() []error { return m }

// Route_StringListValidationError is the validation error returned by
// Route_StringList.Validate if the designated constraints aren't met.
type Route_StringListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Route_StringListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Route_StringListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Route_StringListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Route_StringListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Route_StringListValidationError) ErrorName() string { return "Route_StringListValidationError" }

// Error satisfies the builtin error interface
func (e Route_StringListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoute_StringList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Route_StringListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Route_StringListValidationError{}

// Validate checks the field values on Settings_Certificate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Settings_Certificate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Settings_Certificate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Settings_CertificateMultiError, or nil if none found.
func (m *Settings_Certificate) ValidateAll() error {
	return m.validate(true)
}

func (m *Settings_Certificate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CertBytes

	// no validation rules for KeyBytes

	// no validation rules for Id

	if len(errors) > 0 {
		return Settings_CertificateMultiError(errors)
	}

	return nil
}

// Settings_CertificateMultiError is an error wrapping multiple validation
// errors returned by Settings_Certificate.ValidateAll() if the designated
// constraints aren't met.
type Settings_CertificateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Settings_CertificateMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Settings_CertificateMultiError) AllErrors() []error { return m }

// Settings_CertificateValidationError is the validation error returned by
// Settings_Certificate.Validate if the designated constraints aren't met.
type Settings_CertificateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Settings_CertificateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Settings_CertificateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Settings_CertificateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Settings_CertificateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Settings_CertificateValidationError) ErrorName() string {
	return "Settings_CertificateValidationError"
}

// Error satisfies the builtin error interface
func (e Settings_CertificateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSettings_Certificate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Settings_CertificateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Settings_CertificateValidationError{}

// Validate checks the field values on Settings_DataBrokerClusterNode with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Settings_DataBrokerClusterNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Settings_DataBrokerClusterNode with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Settings_DataBrokerClusterNodeMultiError, or nil if none found.
func (m *Settings_DataBrokerClusterNode) ValidateAll() error {
	return m.validate(true)
}

func (m *Settings_DataBrokerClusterNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for GrpcAddress

	if m.RaftAddress != nil {
		// no validation rules for RaftAddress
	}

	if len(errors) > 0 {
		return Settings_DataBrokerClusterNodeMultiError(errors)
	}

	return nil
}

// Settings_DataBrokerClusterNodeMultiError is an error wrapping multiple
// validation errors returned by Settings_DataBrokerClusterNode.ValidateAll()
// if the designated constraints aren't met.
type Settings_DataBrokerClusterNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Settings_DataBrokerClusterNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Settings_DataBrokerClusterNodeMultiError) AllErrors() []error { return m }

// Settings_DataBrokerClusterNodeValidationError is the validation error
// returned by Settings_DataBrokerClusterNode.Validate if the designated
// constraints aren't met.
type Settings_DataBrokerClusterNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Settings_DataBrokerClusterNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Settings_DataBrokerClusterNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Settings_DataBrokerClusterNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Settings_DataBrokerClusterNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Settings_DataBrokerClusterNodeValidationError) ErrorName() string {
	return "Settings_DataBrokerClusterNodeValidationError"
}

// Error satisfies the builtin error interface
func (e Settings_DataBrokerClusterNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSettings_DataBrokerClusterNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Settings_DataBrokerClusterNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Settings_DataBrokerClusterNodeValidationError{}

// Validate checks the field values on Settings_DataBrokerClusterNodes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Settings_DataBrokerClusterNodes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Settings_DataBrokerClusterNodes with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Settings_DataBrokerClusterNodesMultiError, or nil if none found.
func (m *Settings_DataBrokerClusterNodes) ValidateAll() error {
	return m.validate(true)
}

func (m *Settings_DataBrokerClusterNodes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Settings_DataBrokerClusterNodesValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Settings_DataBrokerClusterNodesValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Settings_DataBrokerClusterNodesValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Settings_DataBrokerClusterNodesMultiError(errors)
	}

	return nil
}

// Settings_DataBrokerClusterNodesMultiError is an error wrapping multiple
// validation errors returned by Settings_DataBrokerClusterNodes.ValidateAll()
// if the designated constraints aren't met.
type Settings_DataBrokerClusterNodesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Settings_DataBrokerClusterNodesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Settings_DataBrokerClusterNodesMultiError) AllErrors() []error { return m }

// Settings_DataBrokerClusterNodesValidationError is the validation error
// returned by Settings_DataBrokerClusterNodes.Validate if the designated
// constraints aren't met.
type Settings_DataBrokerClusterNodesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Settings_DataBrokerClusterNodesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Settings_DataBrokerClusterNodesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Settings_DataBrokerClusterNodesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Settings_DataBrokerClusterNodesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Settings_DataBrokerClusterNodesValidationError) ErrorName() string {
	return "Settings_DataBrokerClusterNodesValidationError"
}

// Error satisfies the builtin error interface
func (e Settings_DataBrokerClusterNodesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSettings_DataBrokerClusterNodes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Settings_DataBrokerClusterNodesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Settings_DataBrokerClusterNodesValidationError{}

// Validate checks the field values on Settings_StringList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Settings_StringList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Settings_StringList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Settings_StringListMultiError, or nil if none found.
func (m *Settings_StringList) ValidateAll() error {
	return m.validate(true)
}

func (m *Settings_StringList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Settings_StringListMultiError(errors)
	}

	return nil
}

// Settings_StringListMultiError is an error wrapping multiple validation
// errors returned by Settings_StringList.ValidateAll() if the designated
// constraints aren't met.
type Settings_StringListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Settings_StringListMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Settings_StringListMultiError) AllErrors() []error { return m }

// Settings_StringListValidationError is the validation error returned by
// Settings_StringList.Validate if the designated constraints aren't met.
type Settings_StringListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Settings_StringListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Settings_StringListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Settings_StringListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Settings_StringListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Settings_StringListValidationError) ErrorName() string {
	return "Settings_StringListValidationError"
}

// Error satisfies the builtin error interface
func (e Settings_StringListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSettings_StringList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Settings_StringListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Settings_StringListValidationError{}

// Validate checks the field values on HealthCheck_HealthStatusSet with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HealthCheck_HealthStatusSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthCheck_HealthStatusSet with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HealthCheck_HealthStatusSetMultiError, or nil if none found.
func (m *HealthCheck_HealthStatusSet) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthCheck_HealthStatusSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HealthCheck_HealthStatusSetMultiError(errors)
	}

	return nil
}

// HealthCheck_HealthStatusSetMultiError is an error wrapping multiple
// validation errors returned by HealthCheck_HealthStatusSet.ValidateAll() if
// the designated constraints aren't met.
type HealthCheck_HealthStatusSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthCheck_HealthStatusSetMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthCheck_HealthStatusSetMultiError) AllErrors() []error { return m }

// HealthCheck_HealthStatusSetValidationError is the validation error returned
// by HealthCheck_HealthStatusSet.Validate if the designated constraints
// aren't met.
type HealthCheck_HealthStatusSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthCheck_HealthStatusSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthCheck_HealthStatusSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthCheck_HealthStatusSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthCheck_HealthStatusSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthCheck_HealthStatusSetValidationError) ErrorName() string {
	return "HealthCheck_HealthStatusSetValidationError"
}

// Error satisfies the builtin error interface
func (e HealthCheck_HealthStatusSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthCheck_HealthStatusSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthCheck_HealthStatusSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthCheck_HealthStatusSetValidationError{}

// Validate checks the field values on HealthCheck_Int64Range with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HealthCheck_Int64Range) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthCheck_Int64Range with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HealthCheck_Int64RangeMultiError, or nil if none found.
func (m *HealthCheck_Int64Range) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthCheck_Int64Range) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for End

	if len(errors) > 0 {
		return HealthCheck_Int64RangeMultiError(errors)
	}

	return nil
}

// HealthCheck_Int64RangeMultiError is an error wrapping multiple validation
// errors returned by HealthCheck_Int64Range.ValidateAll() if the designated
// constraints aren't met.
type HealthCheck_Int64RangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthCheck_Int64RangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthCheck_Int64RangeMultiError) AllErrors() []error { return m }

// HealthCheck_Int64RangeValidationError is the validation error returned by
// HealthCheck_Int64Range.Validate if the designated constraints aren't met.
type HealthCheck_Int64RangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthCheck_Int64RangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthCheck_Int64RangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthCheck_Int64RangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthCheck_Int64RangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthCheck_Int64RangeValidationError) ErrorName() string {
	return "HealthCheck_Int64RangeValidationError"
}

// Error satisfies the builtin error interface
func (e HealthCheck_Int64RangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthCheck_Int64Range.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthCheck_Int64RangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthCheck_Int64RangeValidationError{}

// Validate checks the field values on HealthCheck_Payload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HealthCheck_Payload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthCheck_Payload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HealthCheck_PayloadMultiError, or nil if none found.
func (m *HealthCheck_Payload) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthCheck_Payload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *HealthCheck_Payload_Text:
		if v == nil {
			err := HealthCheck_PayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Text
	case *HealthCheck_Payload_Binary:
		if v == nil {
			err := HealthCheck_PayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Binary
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return HealthCheck_PayloadMultiError(errors)
	}

	return nil
}

// HealthCheck_PayloadMultiError is an error wrapping multiple validation
// errors returned by HealthCheck_Payload.ValidateAll() if the designated
// constraints aren't met.
type HealthCheck_PayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthCheck_PayloadMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthCheck_PayloadMultiError) AllErrors() []error { return m }

// HealthCheck_PayloadValidationError is the validation error returned by
// HealthCheck_Payload.Validate if the designated constraints aren't met.
type HealthCheck_PayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthCheck_PayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthCheck_PayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthCheck_PayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthCheck_PayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthCheck_PayloadValidationError) ErrorName() string {
	return "HealthCheck_PayloadValidationError"
}

// Error satisfies the builtin error interface
func (e HealthCheck_PayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthCheck_Payload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthCheck_PayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthCheck_PayloadValidationError{}

// Validate checks the field values on HealthCheck_HttpHealthCheck with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HealthCheck_HttpHealthCheck) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthCheck_HttpHealthCheck with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HealthCheck_HttpHealthCheckMultiError, or nil if none found.
func (m *HealthCheck_HttpHealthCheck) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthCheck_HttpHealthCheck) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Host

	// no validation rules for Path

	if all {
		switch v := interface{}(m.GetSend()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheck_HttpHealthCheckValidationError{
					field:  "Send",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheck_HttpHealthCheckValidationError{
					field:  "Send",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSend()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheck_HttpHealthCheckValidationError{
				field:  "Send",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetReceive() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HealthCheck_HttpHealthCheckValidationError{
						field:  fmt.Sprintf("Receive[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HealthCheck_HttpHealthCheckValidationError{
						field:  fmt.Sprintf("Receive[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HealthCheck_HttpHealthCheckValidationError{
					field:  fmt.Sprintf("Receive[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetResponseBufferSize()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheck_HttpHealthCheckValidationError{
					field:  "ResponseBufferSize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheck_HttpHealthCheckValidationError{
					field:  "ResponseBufferSize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponseBufferSize()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheck_HttpHealthCheckValidationError{
				field:  "ResponseBufferSize",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetExpectedStatuses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HealthCheck_HttpHealthCheckValidationError{
						field:  fmt.Sprintf("ExpectedStatuses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HealthCheck_HttpHealthCheckValidationError{
						field:  fmt.Sprintf("ExpectedStatuses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HealthCheck_HttpHealthCheckValidationError{
					field:  fmt.Sprintf("ExpectedStatuses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetRetriableStatuses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HealthCheck_HttpHealthCheckValidationError{
						field:  fmt.Sprintf("RetriableStatuses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HealthCheck_HttpHealthCheckValidationError{
						field:  fmt.Sprintf("RetriableStatuses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HealthCheck_HttpHealthCheckValidationError{
					field:  fmt.Sprintf("RetriableStatuses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CodecClientType

	if len(errors) > 0 {
		return HealthCheck_HttpHealthCheckMultiError(errors)
	}

	return nil
}

// HealthCheck_HttpHealthCheckMultiError is an error wrapping multiple
// validation errors returned by HealthCheck_HttpHealthCheck.ValidateAll() if
// the designated constraints aren't met.
type HealthCheck_HttpHealthCheckMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthCheck_HttpHealthCheckMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthCheck_HttpHealthCheckMultiError) AllErrors() []error { return m }

// HealthCheck_HttpHealthCheckValidationError is the validation error returned
// by HealthCheck_HttpHealthCheck.Validate if the designated constraints
// aren't met.
type HealthCheck_HttpHealthCheckValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthCheck_HttpHealthCheckValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthCheck_HttpHealthCheckValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthCheck_HttpHealthCheckValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthCheck_HttpHealthCheckValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthCheck_HttpHealthCheckValidationError) ErrorName() string {
	return "HealthCheck_HttpHealthCheckValidationError"
}

// Error satisfies the builtin error interface
func (e HealthCheck_HttpHealthCheckValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthCheck_HttpHealthCheck.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthCheck_HttpHealthCheckValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthCheck_HttpHealthCheckValidationError{}

// Validate checks the field values on HealthCheck_TcpHealthCheck with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HealthCheck_TcpHealthCheck) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthCheck_TcpHealthCheck with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HealthCheck_TcpHealthCheckMultiError, or nil if none found.
func (m *HealthCheck_TcpHealthCheck) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthCheck_TcpHealthCheck) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSend()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HealthCheck_TcpHealthCheckValidationError{
					field:  "Send",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HealthCheck_TcpHealthCheckValidationError{
					field:  "Send",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSend()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HealthCheck_TcpHealthCheckValidationError{
				field:  "Send",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetReceive() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HealthCheck_TcpHealthCheckValidationError{
						field:  fmt.Sprintf("Receive[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HealthCheck_TcpHealthCheckValidationError{
						field:  fmt.Sprintf("Receive[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HealthCheck_TcpHealthCheckValidationError{
					field:  fmt.Sprintf("Receive[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HealthCheck_TcpHealthCheckMultiError(errors)
	}

	return nil
}

// HealthCheck_TcpHealthCheckMultiError is an error wrapping multiple
// validation errors returned by HealthCheck_TcpHealthCheck.ValidateAll() if
// the designated constraints aren't met.
type HealthCheck_TcpHealthCheckMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthCheck_TcpHealthCheckMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthCheck_TcpHealthCheckMultiError) AllErrors() []error { return m }

// HealthCheck_TcpHealthCheckValidationError is the validation error returned
// by HealthCheck_TcpHealthCheck.Validate if the designated constraints aren't met.
type HealthCheck_TcpHealthCheckValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthCheck_TcpHealthCheckValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthCheck_TcpHealthCheckValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthCheck_TcpHealthCheckValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthCheck_TcpHealthCheckValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthCheck_TcpHealthCheckValidationError) ErrorName() string {
	return "HealthCheck_TcpHealthCheckValidationError"
}

// Error satisfies the builtin error interface
func (e HealthCheck_TcpHealthCheckValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthCheck_TcpHealthCheck.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthCheck_TcpHealthCheckValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthCheck_TcpHealthCheckValidationError{}

// Validate checks the field values on HealthCheck_GrpcHealthCheck with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HealthCheck_GrpcHealthCheck) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthCheck_GrpcHealthCheck with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HealthCheck_GrpcHealthCheckMultiError, or nil if none found.
func (m *HealthCheck_GrpcHealthCheck) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthCheck_GrpcHealthCheck) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceName

	// no validation rules for Authority

	if len(errors) > 0 {
		return HealthCheck_GrpcHealthCheckMultiError(errors)
	}

	return nil
}

// HealthCheck_GrpcHealthCheckMultiError is an error wrapping multiple
// validation errors returned by HealthCheck_GrpcHealthCheck.ValidateAll() if
// the designated constraints aren't met.
type HealthCheck_GrpcHealthCheckMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthCheck_GrpcHealthCheckMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthCheck_GrpcHealthCheckMultiError) AllErrors() []error { return m }

// HealthCheck_GrpcHealthCheckValidationError is the validation error returned
// by HealthCheck_GrpcHealthCheck.Validate if the designated constraints
// aren't met.
type HealthCheck_GrpcHealthCheckValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthCheck_GrpcHealthCheckValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthCheck_GrpcHealthCheckValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthCheck_GrpcHealthCheckValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthCheck_GrpcHealthCheckValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthCheck_GrpcHealthCheckValidationError) ErrorName() string {
	return "HealthCheck_GrpcHealthCheckValidationError"
}

// Error satisfies the builtin error interface
func (e HealthCheck_GrpcHealthCheckValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthCheck_GrpcHealthCheck.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthCheck_GrpcHealthCheckValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthCheck_GrpcHealthCheckValidationError{}
