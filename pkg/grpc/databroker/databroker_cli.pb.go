// Code generated by github.com/kralicky/codegen/cli. DO NOT EDIT.
// source: github.com/pomerium/pomerium/pkg/grpc/databroker/databroker.proto

package databroker

import (
	context "context"
	errors "errors"
	cli "github.com/kralicky/codegen/cli"
	cliutil "github.com/kralicky/codegen/pkg/cliutil"
	flagutil "github.com/kralicky/codegen/pkg/flagutil"
	cobra "github.com/spf13/cobra"
	pflag "github.com/spf13/pflag"
	grpc "google.golang.org/grpc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	strings "strings"
)

type (
	contextKey_DataBrokerService_type      struct{}
	contextInjector_DataBrokerService_type struct{}
)

var (
	contextKey_DataBrokerService     contextKey_DataBrokerService_type
	DataBrokerServiceContextInjector contextInjector_DataBrokerService_type
)

func (contextInjector_DataBrokerService_type) NewClient(cc grpc.ClientConnInterface) DataBrokerServiceClient {
	return NewDataBrokerServiceClient(cc)
}

func (contextInjector_DataBrokerService_type) UnderlyingConn(client DataBrokerServiceClient) grpc.ClientConnInterface {
	return client.(*dataBrokerServiceClient).cc
}

func (contextInjector_DataBrokerService_type) ContextWithClient(ctx context.Context, client DataBrokerServiceClient) context.Context {
	return context.WithValue(ctx, contextKey_DataBrokerService, client)
}

func (contextInjector_DataBrokerService_type) ClientFromContext(ctx context.Context) (DataBrokerServiceClient, bool) {
	client, ok := ctx.Value(contextKey_DataBrokerService).(DataBrokerServiceClient)
	return client, ok
}

var extraCmds_DataBrokerService []*cobra.Command

func addExtraDataBrokerServiceCmd(custom *cobra.Command) {
	extraCmds_DataBrokerService = append(extraCmds_DataBrokerService, custom)
}

func BuildDataBrokerServiceCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "db",
		Short:             `The DataBrokerService stores key-value data.`,
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
	}

	cliutil.AddSubcommands(cmd, append([]*cobra.Command{
		BuildDataBrokerServiceAcquireLeaseCmd(),
		BuildDataBrokerServiceGetCmd(),
		BuildDataBrokerServiceListTypesCmd(),
		BuildDataBrokerServicePutCmd(),
		BuildDataBrokerServicePatchCmd(),
		BuildDataBrokerServiceQueryCmd(),
		BuildDataBrokerServiceReleaseLeaseCmd(),
		BuildDataBrokerServiceRenewLeaseCmd(),
		BuildDataBrokerServiceSetOptionsCmd(),
		BuildDataBrokerServiceSyncCmd(),
		BuildDataBrokerServiceSyncLatestCmd(),
	}, extraCmds_DataBrokerService...)...)
	cli.AddOutputFlag(cmd)
	return cmd
}

func BuildDataBrokerServiceAcquireLeaseCmd() *cobra.Command {
	in := &AcquireLeaseRequest{}
	cmd := &cobra.Command{
		Use:               "acquire-lease",
		Short:             "AcquireLease acquires a distributed mutex lease.",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := DataBrokerServiceContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.AcquireLease(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildDataBrokerServiceGetCmd() *cobra.Command {
	in := &GetRequest{}
	cmd := &cobra.Command{
		Use:               "get",
		Short:             "Get gets a record.",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := DataBrokerServiceContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.Get(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildDataBrokerServiceListTypesCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "list-types",
		Short:             "ListTypes lists all the known record types.",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := DataBrokerServiceContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			response, err := client.ListTypes(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	return cmd
}

func BuildDataBrokerServicePutCmd() *cobra.Command {
	in := &PutRequest{}
	cmd := &cobra.Command{
		Use:               "put",
		Short:             "Put saves a record.",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := DataBrokerServiceContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.Put(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildDataBrokerServicePatchCmd() *cobra.Command {
	in := &PatchRequest{}
	cmd := &cobra.Command{
		Use:               "patch",
		Short:             "Patch updates specific fields of an existing record.",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := DataBrokerServiceContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.Patch(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildDataBrokerServiceQueryCmd() *cobra.Command {
	in := &QueryRequest{}
	cmd := &cobra.Command{
		Use:               "query",
		Short:             "Query queries for records.",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := DataBrokerServiceContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.Query(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildDataBrokerServiceReleaseLeaseCmd() *cobra.Command {
	in := &ReleaseLeaseRequest{}
	cmd := &cobra.Command{
		Use:               "release-lease",
		Short:             "ReleaseLease releases a distributed mutex lease.",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := DataBrokerServiceContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			_, err := client.ReleaseLease(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildDataBrokerServiceRenewLeaseCmd() *cobra.Command {
	in := &RenewLeaseRequest{}
	cmd := &cobra.Command{
		Use:               "renew-lease",
		Short:             "RenewLease renews a distributed mutex lease.",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := DataBrokerServiceContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			_, err := client.RenewLease(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildDataBrokerServiceSetOptionsCmd() *cobra.Command {
	in := &SetOptionsRequest{}
	cmd := &cobra.Command{
		Use:               "set-options",
		Short:             "SetOptions sets the options for a type in the databroker.",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := DataBrokerServiceContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.SetOptions(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildDataBrokerServiceSyncCmd() *cobra.Command {
	in := &SyncRequest{}
	cmd := &cobra.Command{
		Use:               "sync",
		Short:             "Sync streams changes to records after the specified version.",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := DataBrokerServiceContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.Sync(cmd.Context(), in)
			if err != nil {
				return err
			}
			return cli.RenderStreamingOutput(cmd, response)
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildDataBrokerServiceSyncLatestCmd() *cobra.Command {
	in := &SyncLatestRequest{}
	cmd := &cobra.Command{
		Use:               "sync-latest",
		Short:             "SyncLatest streams the latest version of every record.",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := DataBrokerServiceContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.SyncLatest(cmd.Context(), in)
			if err != nil {
				return err
			}
			return cli.RenderStreamingOutput(cmd, response)
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func (in *AcquireLeaseRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("AcquireLeaseRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Name, strings.Join(append(prefix, "name"), "."), "", "Name is the name of the lease. Only a single client can hold the lease on")
	fs.Var(flagutil.DurationpbValue(nil, &in.Duration), strings.Join(append(prefix, "duration"), "."), "Duration is the duration of the lease. After the duration is reached the")
	return fs
}

func (in *GetRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("GetRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Type, strings.Join(append(prefix, "type"), "."), "", "")
	fs.StringVar(&in.Id, strings.Join(append(prefix, "id"), "."), "", "")
	return fs
}

func (in *PutRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("PutRequest", pflag.ExitOnError)
	fs.SortFlags = true
	return fs
}

func (in *PatchRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("PatchRequest", pflag.ExitOnError)
	fs.SortFlags = true
	return fs
}

func (in *QueryRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("QueryRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Type, strings.Join(append(prefix, "type"), "."), "", "")
	fs.StringVar(&in.Query, strings.Join(append(prefix, "query"), "."), "", "")
	fs.Int64Var(&in.Offset, strings.Join(append(prefix, "offset"), "."), 0, "")
	fs.Int64Var(&in.Limit, strings.Join(append(prefix, "limit"), "."), 0, "")
	return fs
}

func (in *ReleaseLeaseRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("ReleaseLeaseRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Name, strings.Join(append(prefix, "name"), "."), "", "")
	fs.StringVar(&in.Id, strings.Join(append(prefix, "id"), "."), "", "")
	return fs
}

func (in *RenewLeaseRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("RenewLeaseRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Name, strings.Join(append(prefix, "name"), "."), "", "")
	fs.StringVar(&in.Id, strings.Join(append(prefix, "id"), "."), "", "")
	fs.Var(flagutil.DurationpbValue(nil, &in.Duration), strings.Join(append(prefix, "duration"), "."), "")
	return fs
}

func (in *SetOptionsRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SetOptionsRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Type, strings.Join(append(prefix, "type"), "."), "", "")
	if in.Options == nil {
		in.Options = &Options{}
	}
	fs.AddFlagSet(in.Options.FlagSet(append(prefix, "options")...))
	return fs
}

func (in *Options) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("Options", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(flagutil.UintPtrValue(nil, &in.Capacity), strings.Join(append(prefix, "capacity"), "."), "capacity sets a maximum size for the given type. Once the capacity is")
	return fs
}

func (in *SyncRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SyncRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Uint64Var(&in.ServerVersion, strings.Join(append(prefix, "server-version"), "."), 0, "")
	fs.Uint64Var(&in.RecordVersion, strings.Join(append(prefix, "record-version"), "."), 0, "")
	fs.StringVar(&in.Type, strings.Join(append(prefix, "type"), "."), "", "")
	return fs
}

func (in *SyncLatestRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SyncLatestRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Type, strings.Join(append(prefix, "type"), "."), "", "")
	return fs
}
